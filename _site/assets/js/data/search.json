[
  
  {
    "title": "Library",
    "url": "/posts/library/",
    "categories": "",
    "tags": "",
    "date": "2023-01-28 00:00:00 +0900",
    





    
    "snippet": "",
    "content": ""
  },
  
  {
    "title": "/Algorithm/ 💚 정렬알고리즘",
    "url": "/posts/sorting-algorithm/",
    "categories": "03.STUDY, Algorithm",
    "tags": "STUDY",
    "date": "2023-01-28 00:00:00 +0900",
    





    
    "snippet": "1. 정렬알고리즘정렬            안정된 정렬      키값이 같은 요소의 순서가 정렬 전후에도 유지되는 것                  안정되지 않은 정렬      키값이 같은 요소의 순서가 정렬 전후에도 유지되지 않는 것                  내부 정렬      정렬할 모든 데이터를 하나의 배열에 저장할 수 있을 때에 사용하는 알...",
    "content": "1. 정렬알고리즘정렬            안정된 정렬      키값이 같은 요소의 순서가 정렬 전후에도 유지되는 것                  안정되지 않은 정렬      키값이 같은 요소의 순서가 정렬 전후에도 유지되지 않는 것                  내부 정렬      정렬할 모든 데이터를 하나의 배열에 저장할 수 있을 때에 사용하는 알고리즘                  외부 정렬      정렬할 데이터가 너무 많아서 하나의 배열에 저장할 수 없을 때에 사용하는 알고리즘                  정렬 알고리즘의 핵심 요소      교환, 선택, 삽입대부분의 정렬 알고리즘은 이 3가지 요소를 응용한 것      2. 버블 정렬bubble sort  단순 교환 정렬(straight exchange sort)  이웃한 두 요소의 대소 관계를 비교하고 필요에 따라 교환을 반복하는 알고리즘버블 정렬 알아보기버블 정렬 프로그램 만들기알고리즘 개선하기 1알고리즘 개선하기23. 단순 선택 정렬4. 단순 삽입 정렬단순 정렬의 시간 복잡도5. 셸 정렬단순삽입 정렬의 특징셸 정렬증분값(h값) 선택하기6. 퀵 정렬퀵 정렬 살펴보기배열을 두 그룹으로 나누기퀵 정렬 구현하기퀵 정렬에서 배열을 나누는 과정 출력하기비재귀적인 퀵 정렬 구현하기스택의 크기 구하기방법1. 요솟수가 많은 그룹을 먼저 푸시하는 경우방법 2. 요솟수가 적은 그룹을 먼저 푸시하는 경우피벗 선택하기퀵 정렬의 시간 복잡도 구하기7. 병합 정렬…8. 힙 정렬9. 도수 정렬(참고링크)  .. 공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다. 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. "
  },
  
  {
    "title": "/Web/ JWT",
    "url": "/posts/jwt/",
    "categories": "03.STUDY, Web",
    "tags": "STUDY",
    "date": "2023-01-27 00:00:00 +0900",
    





    
    "snippet": "0. 쿠키와 세션쿠키최초 로그인 시 ID, PW를 가지고 로그인을 하고 난 이후별 다른 ID, PW 없이 로그인이 된 상태에서 요청을 날릴 수 있다.로그인 시 매번 ID, PW를 작성해서 전달해야한다.쿠키 + 세션ID, PW를 주고받는 대신인증 정보 자체를 특정 세션 저장소에 저장하고,이 값을 쿠키에 담아클라이언트가 쿠키를 요청할 때마다 세션 저장소에...",
    "content": "0. 쿠키와 세션쿠키최초 로그인 시 ID, PW를 가지고 로그인을 하고 난 이후별 다른 ID, PW 없이 로그인이 된 상태에서 요청을 날릴 수 있다.로그인 시 매번 ID, PW를 작성해서 전달해야한다.쿠키 + 세션ID, PW를 주고받는 대신인증 정보 자체를 특정 세션 저장소에 저장하고,이 값을 쿠키에 담아클라이언트가 쿠키를 요청할 때마다 세션 저장소에 있는 정보랑 동일한지로 로그인을 확인1. JWT      공개/개인 키를 쌍으로 사용하여 토큰에 서명할 경우서명된 토큰은 개인 키를 보유한 서버가 이 서명된 토큰이 정상적인 토큰인지 인증        JWT는 일반적으로 클라이언트와 서버, 서비스와 서비스 사이 통신 시권한 인가(Authorization)을 위해 사용하는 토큰        Json 포맷을 이용하여 사용자에 대한 속성을 저장하는Claim 기반의 Web Token        인증에 필요한 정보들을 Token에 담아 암호화시켜 사용하는 토큰  2. JWT를 처리하는 곳로그인을 하게되면서버에서 회원의 정보와 시그니처의 시크릿 키를 이용해access 토큰과 refresh 토큰을 발급한 후에클라이언트에게 넘겨주고리프레쉬는 암호화하여 db에 저장해줍니다.3. JWT 재발급 방식사용자 로그인 시서버는 사용자 인증을 완료하고외부에 노출되어도 문제가 없는 인증관련 정보(사용자 ID, 권한 등)를JSON 형태로 만듭니다.이 데이터를 base64 인코딩을 해서 문자열을 만들고,미리 정한 시스템의 SecretKey를 이용하여 서명 문자열을 생성합니다.4. 어떤 방식으로 검증검증은 이 토큰이 서버가 발급한 토큰이 맞는지 확인합니다.5. JWT 재발급 주기 처리재발급 주기는 평균적으로 access 토큰은 2시간 refresh 토큰은 2주입니다.6. 다른 API 서비스 호출시 어떻게 잡아서 인증을 처리api 통신을 하게되면클라이언트가 header에서엑세스 토큰을 담아서 보내고서버에서 검증한 뒤API 로직이 수행됩니다.(참고링크)  https://brunch.co.kr/@jinyoungchoi95/1 공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다. 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. "
  },
  
  {
    "title": "/web/ 💚 쿠키, 세션, 캐시",
    "url": "/posts/cookie-session/",
    "categories": "03.STUDY, Web",
    "tags": "STUDY",
    "date": "2023-01-27 00:00:00 +0900",
    





    
    "snippet": "(참고링크)    쿠키(Cookie)와 세션(Session) &amp; 로그인 동작 방법 공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다. 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. ",
    "content": "(참고링크)    쿠키(Cookie)와 세션(Session) &amp; 로그인 동작 방법 공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다. 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. "
  },
  
  {
    "title": "/JPA/ N+1 문제",
    "url": "/posts/N+1/",
    "categories": "03.STUDY, JPA",
    "tags": "STUDY",
    "date": "2023-01-27 00:00:00 +0900",
    





    
    "snippet": "1. JPA N+1 문제  N + 1문제란 1번의 쿼리를 날렸을 때의도하지 않은 N번의 쿼리가 추가적으로 실행되는 것EAGER(즉시 로딩)인 경우  JPQL에서 만든 SQL을 통해 데이터를 조회  이후 JPA에서 Fetch 전략을 가지고 해당 데이터의 연관 관계인 하위 엔티티들을 추가 조회  2번 과정으로 N + 1 문제 발생LAZY(지연 로딩)인 경...",
    "content": "1. JPA N+1 문제  N + 1문제란 1번의 쿼리를 날렸을 때의도하지 않은 N번의 쿼리가 추가적으로 실행되는 것EAGER(즉시 로딩)인 경우  JPQL에서 만든 SQL을 통해 데이터를 조회  이후 JPA에서 Fetch 전략을 가지고 해당 데이터의 연관 관계인 하위 엔티티들을 추가 조회  2번 과정으로 N + 1 문제 발생LAZY(지연 로딩)인 경우  JPQL에서 만든 SQL을 통해 데이터를 조회  JPA에서 Fetch 전략을 가지지만, 지연 로딩이기 때문에 추가 조회는 하지 않음  하지만, 하위 엔티티를 가지고 작업하게 되면 추가 조회가 발생하기 때문에 결국 N + 1 문제 발생2. N+1 문제 발생 이유2-1. 언제 발생하는가JPA Repository를 활용해 인터페이스 메소드를 호출할 때(Read 시)2-2. 누가 발생시키는가1:N 또는 N:1 관계를 가진 엔티티를 조회할 때 발생2-3. 어떤 상황에서 발생되는가  연관관계가 설정된 엔티티를 조회할 때 다른 연관관계에 접근하는 경우  JPA Fetch 전략이 EAGER 전략으로 데이터를 조회하는 경우  JPA Fetch 전략이 LAZY 전략으로 데이터를 가져온 이후에연관 관계인 하위 엔티티를 다시 조회하는 경우2-4. 왜 발생하는가  JPA Repository로 find 시실행하는 첫 쿼리에서 하위 엔티티까지 한 번에 가져오지 않고,하위 엔티티를 사용할 때 추가로 조회하기 때문  JPQL은 기본적으로 글로벌 Fetch 전략을 무시하고JPQL만 가지고 SQL을 생성하기 때문3. N+1 문제 해결 방법  JPQL의 fetch join을 사용해 DB에서 데이터를 가져올 때처음부터 연관된 데이터까지 같이 가져오게 하는 방법을 사용해 해결하는 방법          SQL 조인을 사용해 연관된 엔티티를 함께 조회하므로 N+1문제가 발생하지 않음      이경우 1:N 상황에서의 페이징엔 오류가 발생할 수 있기에조인을 제거하고 Batch Size를 조절해 해결 가능        하이버네이트 @BatchSize          1:N 상황에서의 페이징엔 오류가 발생할 수 있기에 조인을 제거하고 Batch Size를 조절해 해결 가능            하이버네이트 @Fetch(FetchMode.SUBSELECT)    EntityGraph (엔티티 그래프)                      Querydsl의 projections을 사용해 해결하는 방법    처음부터 Erd설계를 잘 하는 방법          처음부터 Erd설계를 처음부터 잘 짜 놓으면  이런 문제가 일어날 확률을 줄일 수 있다.      3-1. JPQL의 fetch join  fetch join이란, JPQL에서 성능 최적화를 위해 제공하는 기술  fetch join은 일반 조인과는 다르게SQL 조인 종류가 아닌, JPQL에서 최적화를 위해 제공하는 기술  fetch join을 사용하면JPQL은 연관된 객체의 모든 정보 하나의 객체로 한번에 불러옴  일반 조인과는 달리, 엔티티의 특정 속성만을 가져올 수 없음  fetch join의 단점          패치 조인 대상에는 별칭을 줄 수 없다.      둘 이상의 컬렉션은 패치 조인 할 수 없다.      컬렉션을 패치 조인하면 페이징 API를 사용할 수 없다.      fetch join 사용방법  join과 사용법 자체는 동일하다.단지 fetch join 명령어로 join을 할 뿐이다.  패치 조인은 실제 질의하는 대상 Entity와 Fetch join이 걸려있는 Entity를 포함한 컬럼 함께 SELECT한다.(예시)// MemberRepository.java@Repositorypublic interface MemberRepository extends JpaRepository&lt;Member, Long&gt; {    @Query(\"select m from Member m join fetch m.team \") // (1)    List&lt;Member&gt; findAllMembers();}fetch join 결과 확인// TeamRepository.java@Query(\"SELECT distinct t FROM Team t join fetch t.members\")public List&lt;Team&gt; findAllWithMemberUsingFetchJoin();(사진출처)SQL 조인을 사용하는 방법SQL 조인을 사용해 연관된 엔티티를 함께 조회하므로 N+1문제가 발생하지 않음fetch join을 사용하는 JPQL 예시select m from member m join fetch m.orders그로인해 실행된 SQLSELECT M.*, O.* FROM MEMBER MINNER JOIN ORDERS O ON M.ID=O.MEMBER_ID➡️ 이 예제는 일대다 조인을 해서 결과가 늘어나 중복된 결과가 나타날 수 있다.따라서 JPQL의 DISTICT를 사용해 중복을 제거하는 것이 좋다.3-2. 하이버네이트 @BatchSize하이버네이트 @BatchSize를 사용하면 연관된 엔티티를 조회할 때지정한 size만큼의 SQL의 IN절을 사용해서 조회하게 된다.만약 조회한 회원이 10명일 경우size = 5 로 지정하면 2번의 SQL만 추가로 실행된다.(예시)10건의 데이터를 조회해야할 때BatchSize(size = 5)으로 설정한 경우@Entitypublic class Member {\t\t@org.hibernate.annotation.BatchSize(size = 5)  @OneToMany(mappedBy = \"member\", fetch = FetchType.EAGER)  private List&lt;Order&gt; orders = new ArrayList&lt;Order&gt;();  ...}  즉시로딩          조회 시점에서 10건의 데이터를 모두 조회 하므로 아래의 SQL가 2번 실행된다.        지연로딩          지연로딘된 엔티티를 최초 사용하는 시점에 아래 SQL을 실행해서 5건의 데이터를 미리 로딩해 두게된다.      그리고 6번째 데이터를 사용하면 아래의 SQL를 추가로 실행하게 된다.      SELECT * FROM  ORDERSWHERE MEMBER_ID IN (    ?, ?, ?, ?, ?  )  hibernate.default_batch_fetch_size 속성을 사용하면애플리케이션 전체에 기본으로 @BatchSize를 적용할 수 있다.  &lt;property name =\"hibernate.default_batch_fetch_size\" value=\"5\" /&gt;  3-3. 하이버네이트 @Fetch(FetchMode.SUBSELECT)하이버네이트 fetch 어노테이션에 FetchMode를 SUBSELECT로 사용하면연관된 데이터를 조회할 때 서브 쿼리를 사용해서 N+1문제를 해결할 수 있다.(예)@Entitypublic Class Member {\t  @org.hibernate.annotation.Fetch(FetchMode.SUBSELECT)  @OneToMany(mappdeBy = \"member\", fetch = FetchType.EAGER)  private List&lt;Order&gt; orders = new ArrayList&lt;Order&gt;();  }3-4. Querydsl의 projections을 사용해 해결하는 방법프로젝션(Projection)은 select 절에서 어떤 컬럼들을 조회할지 대상을 지정하는 것을 말한다.프로젝션 대상이 하나일 경우는 타입이 명확하기 때문에 해당 Generic Type이 해당 컬럼 타입에 맞게 지정된다.(프로젝트에서 적용한 사례)원래 서비스단의 공지사항 전체조회 코드@Slf4j@Service@RequiredArgsConstructor@Transactional(readOnly = true)public class NoticeService {\t// 공지사항 전체조회\tpublic Page&lt;NoticeResponseDto&gt; getAllNotice(Pageable pageable) {\t\tPage&lt;Notice&gt; noticeList = noticeRepository.getNoticeList(pageable);\t\tList&lt;NoticeResponseDto&gt; noticeAllList = new ArrayList&lt;&gt;();\t\tfor (Notice notice : noticeList) {\t\t\tnoticeAllList.add(\t\t\t\t\tNoticeResponseDto.builder()\t\t\t\t\t\t\t.id(notice.getId())\t\t\t\t\t\t\t.title(notice.getTitle())\t\t\t\t\t\t\t.noticeContent(notice.getNoticeContent())\t\t\t\t\t\t\t.noticeImgUrl(notice.getNoticeImgUrl())\t\t\t\t\t\t\t.createdAt(notice.getCreatedAt())\t\t\t\t\t\t\t.modifiedAt(notice.getModifiedAt())\t\t\t\t\t\t\t.build()\t\t\t);\t\t}\t\treturn new PageImpl&lt;&gt;(noticeAllList, pageable, noticeList.getTotalElements());\t\treturn noticeRepository.getAllNotices(pageable);\t}}⬇ N+1 문제 해결️@Slf4j@Service@RequiredArgsConstructor@Transactional(readOnly = true)public class NoticeService {\t// 공지사항 전체조회\tpublic Page&lt;NoticeResponseDto&gt; getAllNotice(Pageable pageable) {\t\treturn noticeRepository.getAllNotices(pageable);\t}}public interface NoticeRepositoryCustom {\tNoticeResponseDto getDetailNotice(Long noticeId);\tPage&lt;NoticeResponseDto&gt; getAllNotices(Pageable pageable);\t}@RequiredArgsConstructorpublic class NoticeRepositoryImpl implements NoticeRepositoryCustom {\tprivate final JPAQueryFactory jpaQueryFactory;\t/*\t *\t *  공지사항 전체 조회\t * */\t@Override\tpublic Page&lt;NoticeResponseDto&gt; getAllNotices(Pageable pageable) {\t\tList&lt;NoticeResponseDto&gt; result = jpaQueryFactory.from(notice)\t\t\t\t.select(Projections.constructor(NoticeResponseDto.class,\t\t\t\t\t\tnotice.id,\t\t\t\t\t\tnotice.title,\t\t\t\t\t\tnotice.noticeContent,\t\t\t\t\t\tnotice.noticeImgUrl,\t\t\t\t\t\tnotice.createdAt,\t\t\t\t\t\tnotice.modifiedAt\t\t\t\t))\t\t\t\t.limit(pageable.getPageSize())\t\t\t\t.offset(pageable.getOffset())\t\t\t\t.fetch();\t\treturn new PageImpl&lt;&gt;(result, pageable, result.size());\t}}서비스단의 코드를 확 줄이고,쿼리프로젝션을 사용해 한번 조회시 3번의 쿼리가 오는것을한번만 실행되게 개선했다.(참고)  자바 ORM 표준 JPA 프로그래밍  [JPA] N+1 문제 원인 및 해결방법 알아보기  JPA N+1 문제 해결하기  JPA N+1 문제 해결 방법 및 실무 적용 팁  🎀[Spring] JPA N+1 문제 해결방법(지연로딩 N+1, 2개 이상 ToMany 관계, fetch join, 페이지네이션) 공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다. 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. "
  },
  
  {
    "title": "/OS/ 프로세스, 스레드",
    "url": "/posts/process-thread/",
    "categories": "03.STUDY, OS",
    "tags": "STUDY",
    "date": "2023-01-26 00:00:00 +0900",
    





    
    "snippet": "  　프로세스는 메모리 상에서 실행중인 프로그램을 말하며,스레드는 이 프로세스 안에서 실행되는 흐름 단위를 말한다.　어플리케이션 하나가 프로세스이고,그 안에서의 분기 처리가 스레드가 된다.1. 프로세스process  운영체제로부터 자신만의 고유의 공간과 자원을 할당받는 작업의 단위1-1. 프로세스의 문제점  프로세스 생성에 큰 오버헤드가 있다. (프로...",
    "content": "  　프로세스는 메모리 상에서 실행중인 프로그램을 말하며,스레드는 이 프로세스 안에서 실행되는 흐름 단위를 말한다.　어플리케이션 하나가 프로세스이고,그 안에서의 분기 처리가 스레드가 된다.1. 프로세스process  운영체제로부터 자신만의 고유의 공간과 자원을 할당받는 작업의 단위1-1. 프로세스의 문제점  프로세스 생성에 큰 오버헤드가 있다. (프로세스를 생성할때 많은 시간이 소요됨)  프로세스 컨텍스트 스위칭의 비효율성, 오버헤드가 큼  프로세스 사이에 통신이 어렵다는점 (IPC 사용해야함)  ✔️ IPC      프로세스 간 통신(Inter-Process Communication, IPC)    프로세스들 사이에 서로 데이터를 주고받는 행위 또는 그에 대한 방법이나 경로  2. 스레드thread  할당 받은 자원을 이용하는 실행의 단위  프로세스 내에 여러개가 생길 수 있음  다른 스레드와 공간과 자원을 공유하며 사용스레드의 출현 목적  프로세스보다 크기가 작은 실행 단위 필요  프로세스의 생성 및 소멸에 따른 오버헤드 감소  빠른 컨텍스트 스위칭  프로세스들의 통신 시간, 방법 어려움 해소스레드 주소공간하나의 스레드가 동작하기 위해 총 6개의 공간이 있다.  (1) 사적공간          스레드 코드 공간      스레드 전용 전역변수 공간      스택 공간        (2) 공유공간          데이터 공간      힙 공간이 있다        (3) 커널 스택3. 멀티 프로세스 &amp; 멀티 스레드3-1. 멀티 프로세스  하나의 프로그램을 여러개의 프로세스로 구성하여 각 프로세스가 하나의 작업(task)를 처리하는 것  장점          하나의 프로세스가 잘못 되어도 프로그램은 동작 함        단점          context switching 비용 발생      3-2. 멀티 프로세스  프로그램을 여러개의 쓰레드로 구성하고 각 쓰레드가 작업(task)를 처리하는 것  장점          시스템 자원 소모 감소      처리 비용 감소(실행 속도 향상)      쓰레드간 자원 공유(stack을 제외한 영역)        단점          디버깅 어려움      동기화 이슈 발생      하나의 쓰레드의 오류로 전체 프로세스에 문제 발생      4. Thread Safe  여러 thread가 동시에 사용되어도 안전하단 것  특정 함수 A 와 변수 AA 가 여러 스레드에서 호출되어도 하나의 스레드에서 호출했을 때와 같은 결과가 보장되어야 한다는 의미  함수가 전역 변수를 참조하게 된다면 그 함수는 thread safe 하지 않은 결과가 나올 수 있음✔️ 전역 변수5. Context Switching  CPU 에서 여러 프로세스를 돌아가면서 작업을 처리하는데 이 과정  동작중인 프로세스가 대기를 하면서 해당 프로세스의 상태(Context)를 보관하고 대기 하고 있다가 다시 실행시 복구하는 비용(시간)(참고링크)  [OS] 프로세스와 스레드의 차이  🎀Process, Thread 차이가 뭐예요?  프로세스 간 통신 공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다. 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. "
  },
  
  {
    "title": "/Network/ TCP/IP 계층 모델",
    "url": "/posts/TCP-UDP/",
    "categories": "03.STUDY, Network",
    "tags": "STUDY",
    "date": "2023-01-26 00:00:00 +0900",
    





    
    "snippet": "0. TCP/IP 계층 모델  인터넷 프로토콜 스택의 4계층 (프로토콜=규약)  컴퓨터 네트워크는 여러 통신 계층이 조합된 형태로 구성되어 있다.  각 통신에 참여하는 장비나 프로그램은 각각 맡은 역할이 있고,이 역할을 추상화 한 것을 계층 모델이라고 한다.  각 계층은 독립적으로 맡은 역할을 수행한다.프로토콜            응용 계층(Appli...",
    "content": "0. TCP/IP 계층 모델  인터넷 프로토콜 스택의 4계층 (프로토콜=규약)  컴퓨터 네트워크는 여러 통신 계층이 조합된 형태로 구성되어 있다.  각 통신에 참여하는 장비나 프로그램은 각각 맡은 역할이 있고,이 역할을 추상화 한 것을 계층 모델이라고 한다.  각 계층은 독립적으로 맡은 역할을 수행한다.프로토콜            응용 계층(Application Layer)      웹 서비스, 이메일과 같은 서비스를 사용자에게 제공 &gt; 서비스 내용을 결정                  전송 계층(Transport Layer)      애플리케이션 계층과 인터넷 계층 사이에서 데이터가 올바르게 전달되도록 중계                  인터넷 계층(Internet Layer)      목적지 IP의 어드레스로 데이터를 전달                  네트워크 접근 계층(Network Acess Layer)      네트워크 어댑터와 같은 하드웨어를 통해 데이터를 전달      TCP와 UDP는네트워크의 계층들 중 전송계층에 해당한다.1. 애플리케이션 계층(application)  FTP, HTTP, SSH, SMTP, DNS 등 응용 프로그램이 사용되는 프로토콜 계층  FTP : 장치와 장치 간의 파일을 전송하는 데 사용되는 표준 통신 프로토콜SSH : 보안되지 않은 네트워크서비스를 안전하게 운영하기 위한 암호화 네트워크 프로토콜HTTP : World Wide Web을 위한 데이터 통신의 기초이자, 웹 사이트를 이용하는데 쓰는 프로토콜SMTP : 전자 메일 전송을 위한 인터넷 표준 통신 프로토콜DMS : (Domain Name System) 사람이 읽을 수 있는 　　　 도메인 이름(예: www.amazon.com)을 　　　 머신이 읽을 수 있는 IP 주소(예: 192.0.2.44)로 변환2. 전송계층(transport)  송신자와 수신자를 연결하는 통신 서브스를 제공  연결 지향 데이터 스트림 지원, 신뢰성, 흐름제어 제공  애플리케이션과 인터넷 계층 사이의 데이터가 절달될 때 중계 역할2-1. TCP  패킷 사이의 순서를 보장  연결 지향 방식을 사용한 연결로 신뢰성 구축해수신을 여부를 확인하며 ‘가상회선 패킷 교환 방식’을 사용  3-way handshaking과정을 통해 연결을 설정해 흐름과 혼잡을 제어이 블로그의 다른 글 - /Network/ TCP 3 way handshake  ✔️ 가상회선 패킷 교환방식각 패킷에는 가상회선 식별자가 포함되며모든 패킷을 전송하면 가상회선이 해제되고 패킷들을 전송된 순서대로 도착하는 방식2-2. UDT  TCP와 다르게 패킷 사이의 순서를 보장하지 않고, 수신여부를 확인하지 않음  비연결형 서비스  정보를 주고받을 때 신호 절차를 걸치지 않아 TCP보다 속도가 빠르다.  ✔️ 데이터그램 패킷 교환방식      패킷이 독립적으로 이동하며 최적의 경로를 선택하여 이동    하나의 메세지에서 분할된 여러 패킷은 서로 다른 경로로 전송될 수 있음    패킷 도착한 순서가 다를 수 있는 방식  3. 인터넷 계층  장치로부터 받은 네트워크 패킷을 IP주소로 지정된 목적지로 전송하기 위해 사용되는 계층  IP, ARP, ICMP등이 있음  패킷을 수신해야할 상대의 주소를 지정하여 데이터를 전달  상대방이 제대로 받았는지에 대해 보장하지 않은 비연결형4. 링크 계층(네트워크 접근 계층)  전선, 광섬유, 무선 등으로 실질적으로 데이터를 전달  장치 간에 신호를 주고받는 ‘규칙’을 정하는 계층  물리계층과 데이터 링크 계층으로 나누기도 함          물리 계층: 무선 LAN과 유선LAN을 통해 0과 1로 이루어진 데이터를 보내는 계층      데이터 링크 계층: ‘이더넷 프라임’을 통해 에러 확인, 흐름 제어, 접근 제어를 담당하는 계층      (참고링크)  [TCP/UDP] TCP와 UDP의 특징과 차이  [CS/Network] HTTP 프로토콜(protocol)  면접을 위한 CS전공지식  DNS란 무엇입니까? 공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다. 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. "
  },
  
  {
    "title": "/Network/ TCP 3 way handshake",
    "url": "/posts/TCP-3way-handshake/",
    "categories": "03.STUDY, Network",
    "tags": "STUDY",
    "date": "2023-01-26 00:00:00 +0900",
    





    
    "snippet": "TCP 3 way handshake      TCP/IP 네트워크 환경에서 서버와 클라이언트를 연결하는데 필요한 프로세스        TCP/IP프로토콜을 이용해서 통신을 하는 응용프로그램이데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해상대방 컴퓨터와 사전에 세션을 수립하는 과정(= 전송 제어 프로토콜(TCP)에서  통신을 하는 장치간 서로 ...",
    "content": "TCP 3 way handshake      TCP/IP 네트워크 환경에서 서버와 클라이언트를 연결하는데 필요한 프로세스        TCP/IP프로토콜을 이용해서 통신을 하는 응용프로그램이데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해상대방 컴퓨터와 사전에 세션을 수립하는 과정(= 전송 제어 프로토콜(TCP)에서  통신을 하는 장치간 서로 연결이 잘 되어있는지 확인하는 과정, 방법)  TCP 3 way handshake 과정데이터를 주고받기 전에 서버와 클라이언트가 확인 패킷을 3단계로 교환하여 연결을 맺는다.1) 클라이언트에서　　서버에 SYN 패킷을 보내고 　　( 클라이언트 상태 : SYN_SENT로 변경 )2) 서버는 　　클라이언트로부터 SYN를 받고　　응답 패킷 ACK과 SYN 패킷을 보냄　　( 서버 상태 : LISTEN ➡️ SYS-SENT로 변경 )3) 클라이언트는 　　받은 패킷에 대한 응답으로 ACK 패킷을 서버로 보냄　　( 클라이언트 상태 : ESTABLISHED )　　( 서버 상태 : ESTABLISHED로 변경 )➡️ 위 과정을 통해 서버와 클라이언트는 신뢰된 연결을 맺게 됩니다.  LISTEN \t: 포트가 열려있어서 연결을 기다리고 있는 상태SYS-SENT\t: 연결 요청한 상태(SYN 보냄)SYN_RECEIVED\t: 요청을 받아서(SYN) 응답한 상태(SYN+ACK), 그러나 아직 ACK는 받지 못한 상태임ESTABLISHED\t: 연결된 상태TCP FLAG  SYN: 연결 요청 플래그  ACK: 응답플래그  FIN: 연결종료 플래그  RST: 연결 재설정 플래그  PSH: 밀어넣기  URG: 긴급 데이터 플래그3-way Handshake 확인1. tcpdump로 3-way Handshake 확인test-1 서버(출발지)에서목적지 KT DNS 서버(168.126.63.1) 53 포트 telnet 접속을tcpdump로 덤프를 뜬 내용이다.tcpdump에서는 ACK 플래그를 “.”(점)으로 표시합니다.test-1 ➡️ 서버 : S서버 ➡️ test-1 : S.test-1 ➡️ 서버 : .2. wireshark로 3-way Handshake 확인192.168.210.102(출발지)에서 목적지 KT DNS 서버(168.126.63.1) 53 포트 telnet 접속을 wireshark로 덤프를 뜬 내용이다.클라이언트 ➡️ 서버 : SYN서버 ➡️ 클라이언트 : SYN, ACK 클라이언트 ➡️ 서버 : ACK(참고링크)  ..  [TCP] 3-way Handshake란? / 와이어샤크, tcpdump 확인  [TCP] 4-way Handshake란? / 와이어샤크, tcpdump 확인 공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다. 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. "
  },
  
  {
    "title": "✨TIL - 오늘 한 일",
    "url": "/posts/wil/",
    "categories": "01.TIL/WIL, TIL",
    "tags": "TIL",
    "date": "2023-01-26 00:00:00 +0900",
    





    
    "snippet": "오늘 한 일2023-01-28 업로드1/26 목  알고리즘 조건문 연습  스프링 핵심 원리 1장 + 정리  정렬알고리즘 부분 읽고 + 정리  프러그래머스 SQL 5문제  두잇 연습문제  CS 질문 1개 정리  저녁약속1/27 금",
    "content": "오늘 한 일2023-01-28 업로드1/26 목  알고리즘 조건문 연습  스프링 핵심 원리 1장 + 정리  정렬알고리즘 부분 읽고 + 정리  프러그래머스 SQL 5문제  두잇 연습문제  CS 질문 1개 정리  저녁약속1/27 금"
  },
  
  {
    "title": "📒 알고리즘 제어문",
    "url": "/posts/%EC%A0%9C%EC%96%B4%EB%AC%B8/",
    "categories": "04.AlGORITHM",
    "tags": "STUDY",
    "date": "2023-01-25 00:00:00 +0900",
    





    
    "snippet": "1. 조건문1-1. if문if~else문  if문은 조건에 따라 두 대의 문장중에 하나가 수행되는 조건문if(조건식)    실행 문장1;else    실행 문장2;if ~ else if문  if ~ else if문은 if문을 이용하여 다중 선택을 가능하게 해준다.if(조건식1)    실행 문장1;else if(조건식2)    실행 문장2;...else...",
    "content": "1. 조건문1-1. if문if~else문  if문은 조건에 따라 두 대의 문장중에 하나가 수행되는 조건문if(조건식)    실행 문장1;else    실행 문장2;if ~ else if문  if ~ else if문은 if문을 이용하여 다중 선택을 가능하게 해준다.if(조건식1)    실행 문장1;else if(조건식2)    실행 문장2;...else    실행 문장3;처음 조건식이 참으로 평가되면 해당 식을 수행한 후, if문장을 빠져 나가게 된다. 처음 조건절이 거짓으로 평가되면 계속해서 else if 조건절을 평가하여 수행한다.1-2. switchswitch ~ case문switch(수식) {    case 값1:        실행 문장1;       break;    case 값2:         실행 문장2;        break;  .....   case 값n:        실행 문장n;        break;   defulat:        디폴트 실행 문장;}중첩된 switch문2. 반복문분기문while문  사전판단반복while (제어식) 명령문/* while 문으로 1, 2, …, n의 합을 구함 */  int sum = 0; // 합   int i = 1;    while (i &lt;= n) { // i가 n 이하면 반복함  sum += i; // sum에 i를 더함  i++; // i값을 1만큼 증가시킴  }for 문 반복  하나의 변수를 사용하는 반복문은 while 문보다 for 문을 사용하는 것이 좋음for (초기화 부분; 제어식; 업데이트 부분) 명령문/* for 문으로 1, 2, …, n의 합을 구함 */ int sum = 0; // 합    for (int i = 1; i &lt;= n; i++)   sum += i; // sum에 i를 더함do/*양수만 입력하여 1, 2, …, n의 합을 구함 *///n이 0보다 클 때까지 반복합니다 do {   System.out.print(\"n값: \");   n = stdIn.nextInt();   } while (n &lt;= 0);if(참고)  두잇  Java 제어문(Control statement)의 조건문(Conditional statement) 공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다. 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. "
  },
  
  {
    "title": "/Database/ DBMS",
    "url": "/posts/DBMS/",
    "categories": "03.STUDY, Database",
    "tags": "STUDY",
    "date": "2023-01-25 00:00:00 +0900",
    





    
    "snippet": "DBMSDataBase Management System, 데이터베이스 관리 시스템(관계형 데이터베이스에 한정하는 것을 강조하고 싶은 경우에는 RDBMS을 사용하기도 함)  예)● Oracle● SQL Server● DB2● MySQL● PostgreSQL● Firebird1. 관계형 데이터베이스Relational DataBase, RDB  데이터를 2...",
    "content": "DBMSDataBase Management System, 데이터베이스 관리 시스템(관계형 데이터베이스에 한정하는 것을 강조하고 싶은 경우에는 RDBMS을 사용하기도 함)  예)● Oracle● SQL Server● DB2● MySQL● PostgreSQL● Firebird1. 관계형 데이터베이스Relational DataBase, RDB  데이터를 2차원 표를 사용해 관리하는 데이터베이스여기서 말하는 Relational(관계)은 2차원 표를 표기할 때 사용하는 단어이다.엔지니어가 보기에 가장 익숙한 2차원 표는Excel이나 Google Docs로 대표되는 스프레드시트가 있다.관계형 데이터베이스의 이점  프로그래밍 언어를 사용하지 않아도 데이터를 조작할 수 있다.  결국 프로그래밍 언어를 습득하지 않아도, 프로 엔지니어나 프로그래머가 아니어도 데이터 조작이 가능하다.  이것을 가능하게 한 것이 관계형 데이터베이스에 있는 ‘SQL’이라는 언어다.  ✔️ CSV 파일로 데이터를 조작하는 경우(관계형 데이터베이스를 사용하지 않았을 때)      이 자체는 매우 간단한 로직이지만 프로그래밍 언어의 지식이 필요하고,    프로그램을 실행하기 위한 환경도 준비해야 한다.    또한, 갱신이나 제거를 수행하는 경우에도 이를 실행할 수 있는 프로그램을 작성해야한다.  2. SQL 기초 지식Structured Query Language(SQL)  데이터베이스에는 4가지 기본 조작(검색, 등록, 갱신, 제거)에 대응하는 명령어 존재          SELECT(검색)      INSERT(등록)      UPDATE(갱신)      DELETE(제거)        장점          일반 프로그래밍 언어와 비해 간결하게 기술      프로그래밍 언어에 사용되는 반복(FOR/WHILE)이나 조건 분기(IF/CASE)를 사용하지 않아도 데이터 조작을 할 수 있음        관계형 데이터베이스의 구조          테이블                  관계형 데이터베이스에서 데이터를 관리하기 위한 유일한 단위          ‘어떤 테이블에 어떤 데이터를 포함하는가’          시스템의 기능을 좌우          테이블에 많은 정보를 채워 넣는다고 하면 정보의 정합성을 유지 관리하기가 어렵고,데이터를 너무 엄격하게 분산시키면 성능이 나빠지니 주의해서 설계해야함                    열(컬럼) 행      3. 관계형 데이터베이스를 다루기 위한 사전 지식DBMS와 데이터베이스의 차이데이터베이스’와 ‘DBMS’란 단어는 실제 개별환경에서도 별로 구분되지 않고 사용되는 경우가 많지만, 둘은 약간 다르다.  데이터베이스: 기능이나 구조를 나타내는 추상적인 개념  DBMS: 데이터베이스(기능이나 구조를 나타내는 추상적인 개념)를 실현하기 위해 작성된 구체적인 소프트웨어  Oracle이나 MySQL 같은 제품은 ‘DBMS이며 데이터베이스는 아니다’가 바른 표현  ‘MySQL은 DBMS의 한 가지다’ - 맞는 표현  ‘MySQL은 데이터베이스의 한 가지다’ - ‘추상’과 ‘구상’을 혼동한 이상한 표현          MySQL: 구체적으로 조작하는 것이 가능한 물리적 실체를 동반한 제품(구현Implementation)      데이터베이스: 기능의 집합을 나타내는 추상적 개념      소프트웨어와 데이터베이스의 관계  SI(System Integration)          데이터베이스와 다른 여러 가지 소프트웨어와 조합해서 시스템을 만드는 작업(단순히 데이터베이스만으로는 구축할 수 없음)      어떤 소프트웨어를 조합할지는 그 시스템의 목적이나 규모에 따라 다름      사용되는 소프트웨어는 크게 다음 3가지로 구분할 수 있음① 운영체제② 미들웨어③ 애플리케이션      사진출처➡️ 3가지 소프트웨어는 계층성이 있으며     한 레이어(계층)의 소프트웨어가 동작하지 않으면     상위 레이어의 소프트웨어는     설치해도 동작하지 않거나 설치조차 할 수 없는 제약이 발생  DBMS는 운영체제와 애플리케이션의 ‘중간(미들)’에 있으며,기능적으로 양쪽의 성질을 겸비해서 갖추고 있어 미들웨어에 해사진출처(참고)  데이터베이스"
  },
  
  {
    "title": "✨TIL - 오늘 한 일",
    "url": "/posts/til-230125/",
    "categories": "01.TIL/WIL, TIL",
    "tags": "TIL",
    "date": "2023-01-25 00:00:00 +0900",
    





    
    "snippet": "오늘 한 일  재귀 알고리즘 책읽고 정리  데이터베이스 2장 읽고 정리  스터디 백준문제 5개 풀기          스터디 백준문제 2개 풀기        프로그래머스 SQL select문 문제 5개  SQL 예시코드&amp;퀴즈 블로그 정리  알고리즘 책 연습문제  스터디(CS &amp; 알고리즘)  스프링 핵심원리 강의 섹션1 + 정리",
    "content": "오늘 한 일  재귀 알고리즘 책읽고 정리  데이터베이스 2장 읽고 정리  스터디 백준문제 5개 풀기          스터디 백준문제 2개 풀기        프로그래머스 SQL select문 문제 5개  SQL 예시코드&amp;퀴즈 블로그 정리  알고리즘 책 연습문제  스터디(CS &amp; 알고리즘)  스프링 핵심원리 강의 섹션1 + 정리"
  },
  
  {
    "title": "/database/ database 의 용도,역할",
    "url": "/posts/db-roll/",
    "categories": "03.STUDY, Database",
    "tags": "STUDY",
    "date": "2023-01-24 00:00:00 +0900",
    





    
    "snippet": "1. 데이터베이스 관련 예시            주변에서 데이터를 관리하는 사례      스마트폰 주소록, 메일 주소록, 은행이나 우체국의 예금통장, 명함 홀더, 사진 앨범, 음악 플레이어의 음악 데이터, 게임기나 온라인 게임의 데이터, 온라인 달력, 거래처의 고객정보 등                  데이터베이스가 사용될 것 같은 도구나 서비스의 예...",
    "content": "1. 데이터베이스 관련 예시            주변에서 데이터를 관리하는 사례      스마트폰 주소록, 메일 주소록, 은행이나 우체국의 예금통장, 명함 홀더, 사진 앨범, 음악 플레이어의 음악 데이터, 게임기나 온라인 게임의 데이터, 온라인 달력, 거래처의 고객정보 등                  데이터베이스가 사용될 것 같은 도구나 서비스의 예      은행이나 우체국의 예금관리, 쇼핑 사이트나 옥션 사이트, 항공기나 영화 등의 티켓 예약 서비스, iTunes Store, 메일 매거진, Dropbox나SugarSync, EVENOTE 등의 온라인 저장소, Facebook이나 Instagram 등의 소셜 네트워크 서비스 등        데이터 유출 등의 사회적 사건의 예          2016년: 인터파크                  1,000만 명 개인정보 유출                    뱅크샐러드?      2021년: 트위치                  서버 구성 오류로 인해 트위치의 중요 정보가 뚫린 이번 사건          원인 : 트위치 서버 설정 변경 후 악성 서드파티 공격이 이루어졌다고 설명했다.(관련기사(유출 데이터 내역 등))                    2022년: 페이스북                  5억 명 이상의 페이스북 사용자의 개인 정보가 온라인에 게시된 데이터 유출          원인: 회사는 ‘악의적인 행위자’가 페이스북 프로필에서 데이터를 스크랩한 것으로 믿고 있다고 말했다.(관련기사)                    2.데이터베이스의 기본기능1.데이터의 검색과 갱신  넓은 의미에서의 갱신: 등록, 수정, 제거  데이터 포맷에 유의: ex. 고유성(같아보여도 다른데이터라는 것을 알도록 관리해야함)  처리성능에 유의: 데이터양이 증가하고 있음에 따라 검색 성능을 향상시키는 것에 대한 고민필요2. 동시성 제어  다수의 사용자가 동시에 파일을 열어 수정할 수 있는 것들에 대한 갱신의 무결성 정도  동시에 갱신을 시도했을 때의 동작 예시(1) 최초로 파일을 연 사람이 파일을 열고 있을 때 　　그다음으로 파일을 열려고 한 사람은 파일을 열 수 없다.(2) 최초로 파일을 연 사람이 파일을 열고 있을 때 　　 그다음으로 파일을 열려고 한 사람에게는　　 파일이 ‘읽기 전용Read Only’으로밖에 열리지 않는다.(3) 어떤 사람도 문제없이 파일을 여는 것이 가능하고 나중에 수행된 쪽의 갱신이 반영된다.　　 (더티쓰기(Dirty Write))  괴로운 트레이오프의 관계          데이터베이스를 복수의 사용자가 동시에 공유하고 이용하려고 한다면같은 데이터를 갱신하는 상황대한 제어가 필요      트레이드오프 관계: 어느 사용자에게는 괜찮은 갱신 제어가 다른 사용자에게는 불편한 상황        ✔️ 더티쓰기(Dirty Write)-남보다 늦게 손을 내밀어 이기는 가위바위보 같은 것-데이터베이스에서 이런 식의 제어는 일반적으로 데이터 무결성 관점에서 기피하는 경향이 있음3. 장애 대응  데이터 소실 사건 발생 :데이터베이스에 보존된 데이터가 어떤 원인으로 소실되고 또한 복원도 되지 않는 경우에 발생  데이터 소실 문제의 대책          데이터 다중화                  데이터를 한 곳이 아니라, 복수의 장소에 분산해서 유지          데이터가 완전히 소실되는 것을 막는 방법          예방책          ‘달걀을 한 바구니에 다 담지 마라’                    백업                  데이터 소실이 발생했을 때 데이터를 복원하는 방법          사후대책                      왜 데이터 소실 사건이 끊이지 않는가          엔지니어가 항상 ‘서비스 레벨’과 ‘비용’이란 트레이드오프의 딜레마로 고민하기 때문즉, 알고는 있지만 돈이 없는 상황이기 때문      4. 보안  데이터베이스가 사용자로부터 가능한 보이지 않게 설계되는 이유          사용자는 서버를 의식할 필요가 없다.                  사용자에게 가까운 기술은 보통 대다수가 클라이언트 기술 중심(태블릿, 스마트폰 등)          서버에 배치된 데이터베이스 등의 소프트웨어를 직접 조작하는 일은 없기 때문                    데이터베이스는 기밀성이 높다.                  데이터베이스에 들어 있는 데이터는기밀성이 지극히 높아서 일반에 공개할 수 없는 내용이 상당수 포함되어 있기 때문          시스템을 구축하는 측에서는‘데이터베이스는 절대 사용자에게는 알려지지 않아야 한다’라는 강한 의지로 시스템을 구축                    3. 데이터베이스의 종류  계층형 데이터베이스          현대적인 데이터베이스 역사상 최초로 등록된 것      상당히 오래되었지만, 아직 현역으로도 이용        관계형 데이터베이스          2차원 표 형식      현재 가장 주류        객체지향 데이터베이스와 XML 데이터베이스          각각 ‘객체’와 ‘XML’이라는 형식으로 데이터를 관리하는 데이터베이스      관계형 데이터베이스를 대체하기를 기대했지만, 아직 관계형 데이터베이스의 아성을 무너뜨리지는 못하였고 틈새시장에서 기반을 쌓고 있는 정도        NoSQL 데이터베이스(Not only SQL)          관계형 데이터베이스에 있는 기능 일부를 버려서 성능(처리 속도)을 높이고 있음      대량의 데이터를 고속으로 처리해야 하는 웹 서비스와 잘 맞아서 최근 자주 이용      (참고자료)  데이터베이스 첫걸음 공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다. 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. "
  },
  
  {
    "title": "/Algorithm/ 💚 재귀 알고리즘",
    "url": "/posts/recursion-algorithm/",
    "categories": "03.STUDY, Algorithm",
    "tags": "STUDY",
    "date": "2023-01-24 00:00:00 +0900",
    





    
    "snippet": "재귀란?어떤 사건이 자기 자신을 포함하고 있거나 또는 자기 자신을 사용하여 정의하고 있을 때이를 재귀적(recursive)이라고 한다.팩토리얼 구하기(n!)factorial  팩토리얼(n!)• 0! = 1• n &gt; 0이면 n! = n × (n — 1)!10! = 10 x 9! 9! =  9 x 8!/*  팩토리얼값을 재귀적으로 구함 */stati...",
    "content": "재귀란?어떤 사건이 자기 자신을 포함하고 있거나 또는 자기 자신을 사용하여 정의하고 있을 때이를 재귀적(recursive)이라고 한다.팩토리얼 구하기(n!)factorial  팩토리얼(n!)• 0! = 1• n &gt; 0이면 n! = n × (n — 1)!10! = 10 x 9! 9! =  9 x 8!/*  팩토리얼값을 재귀적으로 구함 */static int factorial(int n) {  if (n &gt; 0)    return n * factorial(n - 1);  else    return 1; }/*  팩토리얼값을 조건 연산자를 사용하여 구현 */return (n &gt; 0) ? n * factorial(n - 1) : 1;  ‘팩토리얼값을 구하는 예’는 재귀의 원리를 이해하기에는 좋지만효율적인 알고리즘은 아니다.재귀 호출  ‘자기 자신과 똑같은 메서드’를 호출factorial 메서드는n - 1의 팩토리얼값을 구하기 위해 다시 factorial 메서드를 호출한다.이러한 메서드 호출 방식을 재귀 호출(recursive call)이라고 한다.직접재귀와 간접재귀            직접(direct) 재귀      자신과 동일한 메서드를 호출다( a ).                  간접(indirect) 재귀는      메서드 a가 메서드 b를 호출하고,다시 메서드 b가 메서드 a를 호출하는 구조( b ).      1-3. 유클리드 호제법두 정수의 최대공약수(greatest common divisor)를 재귀적으로 구하는 방법컴퓨터를 이용해 최대공약수를 찾을 때는, 소인수분해를 하기 보다는 유클리드 호제법이라는 알고리즘(문제를 풀기 위해 정해진 절차)를 사용하는 것이 더 빠르다.  최대공약수: gcd(a,b)최소공배수: lcm(a,b)a, b로 나눈 몫 Q, 나머지 Rgcd(a,b) = gcd(b,R)ex) gcd (60, 24) = gcd (24 ,12) = 12　• y = 0일 때 최대공약수: x• y ≠ 0일 때 최대공약수: gcd(y, x % y)// 정수 x, y의 최대공약수를 구하여 반환static int gcd(int x, int y) {   if (y == 0)     return x;   else    return gcd(y, x % y);}2. 재귀 알고리즘 분석2-1. 재귀 알고리즘 분석하기하향식 분석  ✔️ recur(3)의 호출..상향식 분석2-2. 재귀 알고리즘의 비재귀적 표현꼬리 재귀의 제거재귀의 제거2-3. 메모화3. 하노이의 탑4. 8퀸 문제4-1. 퀸 배치하기4-2. 분기 조작4-3. 분기 한정법4-4. 8퀸 문제를 해결하는 프로그램 만들기(참고)  두잇! 알고리 기초  재귀알고리즘 분석  재귀함수와 꼬리 재귀  정수론 (1) - 최대공약수, 최소공배수, 유클리드 호제법  최대공약수와 최소공배수 공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다. 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. "
  },
  
  {
    "title": "❗ERROR - git blog ArgumentError",
    "url": "/posts/0004/",
    "categories": "02.ERROR",
    "tags": "error",
    "date": "2023-01-24 00:00:00 +0900",
    





    
    "snippet": "&gt; Run bash tools/testConfiguration file: /home/runner/work/ggggraceful.github.io/ggggraceful.github.io/_config.yml Theme Config file: /home/runner/work/ggggraceful.github.io/ggggraceful.github.i...",
    "content": "&gt; Run bash tools/testConfiguration file: /home/runner/work/ggggraceful.github.io/ggggraceful.github.io/_config.yml Theme Config file: /home/runner/work/ggggraceful.github.io/ggggraceful.github.io/_config.yml            Source: /home/runner/work/ggggraceful.github.io/ggggraceful.github.io       Destination: /home/runner/work/ggggraceful.github.io/ggggraceful.github.io/_sitebaseurl: '' Incremental build: disabled. Enable with --incremental      Generating...                     done in 2.885 seconds. Auto-regeneration: disabled. Use --watch to enable.htmlproofer 3.19.4 | Error:  _site does not exist/home/runner/work/ggggraceful.github.io/ggggraceful.github.io/vendor/bundle/ruby/3.2.0/gems/html-proofer-3.19.4/lib/html-proofer.rb:25:in `check_file': _site does not exist (ArgumentError)    raise ArgumentError, \"#{file} does not exist\" unless File.exist?(file)          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\tfrom /home/runner/work/ggggraceful.github.io/ggggraceful.github.io/vendor/bundle/ruby/3.2.0/gems/html-proofer-3.19.4/bin/htmlproofer:114:in `block (2 levels) in &lt;top (required)&gt;'\tfrom /home/runner/work/ggggraceful.github.io/ggggraceful.github.io/vendor/bundle/ruby/3.2.0/gems/mercenary-0.4.0/lib/mercenary/command.rb:221:in `block in execute'\tfrom /home/runner/work/ggggraceful.github.io/ggggraceful.github.io/vendor/bundle/ruby/3.2.0/gems/mercenary-0.4.0/lib/mercenary/command.rb:221:in `each'\tfrom /home/runner/work/ggggraceful.github.io/ggggraceful.github.io/vendor/bundle/ruby/3.2.0/gems/mercenary-0.4.0/lib/mercenary/command.rb:221:in `execute'\tfrom /home/runner/work/ggggraceful.github.io/ggggraceful.github.io/vendor/bundle/ruby/3.2.0/gems/mercenary-0.4.0/lib/mercenary/program.rb:44:in `go'\tfrom /home/runner/work/ggggraceful.github.io/ggggraceful.github.io/vendor/bundle/ruby/3.2.0/gems/mercenary-0.4.0/lib/mercenary.rb:21:in `program'\tfrom /home/runner/work/ggggraceful.github.io/ggggraceful.github.io/vendor/bundle/ruby/3.2.0/gems/html-proofer-3.19.4/bin/htmlproofer:11:in `&lt;top (required)&gt;'\tfrom /home/runner/work/ggggraceful.github.io/ggggraceful.github.io/vendor/bundle/ruby/3.2.0/bin/htmlproofer:25:in `load'\tfrom /home/runner/work/ggggraceful.github.io/ggggraceful.github.io/vendor/bundle/ruby/3.2.0/bin/htmlproofer:25:in `&lt;top (required)&gt;'\tfrom /opt/hostedtoolcache/Ruby/3.2.0/x64/lib/ruby/3.2.0/bundler/cli/exec.rb:58:in `load'\tfrom /opt/hostedtoolcache/Ruby/3.2.0/x64/lib/ruby/3.2.0/bundler/cli/exec.rb:58:in `kernel_load'\tfrom /opt/hostedtoolcache/Ruby/3.2.0/x64/lib/ruby/3.2.0/bundler/cli/exec.rb:23:in `run'\tfrom /opt/hostedtoolcache/Ruby/3.2.0/x64/lib/ruby/3.2.0/bundler/cli.rb:491:in `exec'\tfrom /opt/hostedtoolcache/Ruby/3.2.0/x64/lib/ruby/3.2.0/bundler/vendor/thor/lib/thor/command.rb:27:in `run'\tfrom /opt/hostedtoolcache/Ruby/3.2.0/x64/lib/ruby/3.2.0/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'\tfrom /opt/hostedtoolcache/Ruby/3.2.0/x64/lib/ruby/3.2.0/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'\tfrom /opt/hostedtoolcache/Ruby/3.2.0/x64/lib/ruby/3.2.0/bundler/cli.rb:34:in `dispatch'\tfrom /opt/hostedtoolcache/Ruby/3.2.0/x64/lib/ruby/3.2.0/bundler/vendor/thor/lib/thor/base.rb:485:in `start'\tfrom /opt/hostedtoolcache/Ruby/3.2.0/x64/lib/ruby/3.2.0/bundler/cli.rb:28:in `start'\tfrom /opt/hostedtoolcache/Ruby/3.2.0/x64/lib/ruby/gems/3.2.0/gems/bundler-2.4.1/libexec/bundle:45:in `block in &lt;top (required)&gt;'\tfrom /opt/hostedtoolcache/Ruby/3.2.0/x64/lib/ruby/3.2.0/bundler/friendly_errors.rb:117:in `with_friendly_errors'\tfrom /opt/hostedtoolcache/Ruby/3.2.0/x64/lib/ruby/gems/3.2.0/gems/bundler-2.4.1/libexec/bundle:33:in `&lt;top (required)&gt;'\tfrom /opt/hostedtoolcache/Ruby/3.2.0/x64/bin/bundle:25:in `load'\tfrom /opt/hostedtoolcache/Ruby/3.2.0/x64/bin/bundle:25:in `&lt;main&gt;'Error: The operation was canceled."
  },
  
  {
    "title": "✨TIL - 오늘 한 일",
    "url": "/posts/til-230124/",
    "categories": "01.TIL/WIL, TIL",
    "tags": "TIL",
    "date": "2023-01-24 00:00:00 +0900",
    





    
    "snippet": "오늘 한 일  데이터베이스 책 1강 읽고 정리  CS 공부 및 정리 4개  SQL 4주차 강의  프로그래머스 SQL select문 5문제 연습          프로그래머스 문제 블로그 정리        알고리즘 책 읽고, 재귀 알고리즘  알고리즘 책 연습문제",
    "content": "오늘 한 일  데이터베이스 책 1강 읽고 정리  CS 공부 및 정리 4개  SQL 4주차 강의  프로그래머스 SQL select문 5문제 연습          프로그래머스 문제 블로그 정리        알고리즘 책 읽고, 재귀 알고리즘  알고리즘 책 연습문제"
  },
  
  {
    "title": "/OS/ 동시성, 병렬성",
    "url": "/posts/concurrency-parallelism/",
    "categories": "03.STUDY, OS",
    "tags": "STUDY",
    "date": "2023-01-23 00:00:00 +0900",
    





    
    "snippet": "동시성과 병렬성            동시성(Concurrency)      병렬성(Parallelism)                  논리적인 개념      물리적인 개념              병렬성을 가능하게 함      동시성의 하위집합              작업이 빠르게 번갈아가며 실행되기에동시에 실행되는 것 같이 보이는 것      실제로...",
    "content": "동시성과 병렬성            동시성(Concurrency)      병렬성(Parallelism)                  논리적인 개념      물리적인 개념              병렬성을 가능하게 함      동시성의 하위집합              작업이 빠르게 번갈아가며 실행되기에동시에 실행되는 것 같이 보이는 것      실제로 동시에 여러 작업이 처리되는 것              싱글 코어에서멀티 쓰레드(Multi thread)를 동작 시키는 방식      멀티 코어에서 멀티 쓰레드(Multi thread)를 동작시키는 방식(= 멀티코어 프로세서 구조와 같음)              하나의 코어만 필요      최소 2개의 코어 필요              한번에 많은 것을 처리      한번에 많은 일을 처리              소프트웨어 설계에 관한 것      하드웨어에 관한 것      스레드 동기화 문제레이스 컨디션(Race Condition)교착 상태(Deadlock)기아 상태(Starvation)라이브락(Livelock)—(참고링크)  동시성(Concurrency) vs 병렬성(Parallelism)  Concurrency vs Parallelism  [OS] 스레드 동기화 문제 - Race Condition, Deadlock, Starvation, Livelock 공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다. 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. "
  },
  
  {
    "title": "/Java/ 클래스, 객체, 인스턴스",
    "url": "/posts/class-instance/",
    "categories": "03.STUDY, Java",
    "tags": "STUDY",
    "date": "2023-01-23 00:00:00 +0900",
    





    
    "snippet": "  자바에서는 하나의 클래스로부터: 여러 개의 인스턴스를 생성할 수 있다.이렇게 생성된 인스턴스는: 독립된 메모리 공간에 저장된 자신만의 필드를 가질 수 있다.하지만 해당 클래스의 모든 메소드(method)는: 해당 클래스에서 생성된 모든 인스턴스가 공유하게 된다.1. 클래스class  연관되어 있는 변수와 메서드의 집합  객체를 만들어 내기 위한 설...",
    "content": "  자바에서는 하나의 클래스로부터: 여러 개의 인스턴스를 생성할 수 있다.이렇게 생성된 인스턴스는: 독립된 메모리 공간에 저장된 자신만의 필드를 가질 수 있다.하지만 해당 클래스의 모든 메소드(method)는: 해당 클래스에서 생성된 모든 인스턴스가 공유하게 된다.1. 클래스class  연관되어 있는 변수와 메서드의 집합  객체를 만들어 내기 위한 설계도라 볼 수 있다.  특징          실체가 없다.      객체가 가지는 공통된 속성과 기능을 정의한다.      객체를 생성할 수 있는 생성자를 가진다.      객체를 해제하는 메서드를 가진다. [ 현대 언어에서는 GC가 호출해준다. ]        class          필드(field)                  객체의 상태를 나타냄          클래스에 포함된 변수(variable)                    메소드(method)                  객체의 행동을 나타냄          어떠한 특정 작업을 수행하기 위한 명령문의 집합                      Java에서의 클래스 =  필드(속성을 표현) + 메소드(기능을 표현)2. 객체Object  소프트웨어 세계에 구현할 대상  클래스에 선언된 모양 그대로 생성된 실체  객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖는다.  특징          클래스를 통해 생성할 대상이다.      소프트웨어적인 관점에서 보면 생성자를 통해 구현체가 되지 않았으며 클래스의 타입으로 명시된 상황이다.      메모리에 올라올 구현체를 위한 참조만 가진다.      이해관계자를 위한 현실세계의 문제점을 소프트웨어로 해결하기 위한 매개체이다.      3. 인스턴스Instance자바에서 클래스를 사용하기 위해서는 우선 해당 클래스 타입의 객체(object)를 선언해야 한다.이렇게 클래스로부터 객체를 선언하는 과정을 클래스의 인스턴스화라고 한다.  설계도인 클래스를 바탕으로 구현된 구체적인 실체/객체  객체가 메모리에 할당되어 실제 사용될 때 인스턴스라고 부른다.이때 인스턴스는 힙 영역의 메모리에 할당 된다.  개념적으로 인스턴스는 객체와 같거나 객체에 포함된다고 봐도 틀린말이 아니다.  특징          new 연산자를 통해 생성자를 호출해서 메모리에 올라온 객체의 상태를 의미한다.      세부적인 속성값, 유일 값을 지니며 소프트웨어의 생애주기에 참여하여 동작한다.(꼭 유일해야 하는 것은 아니다)      객체는 인스턴스보다 더 포괄적인 단계이다.      런타임에 작동하는 객체를 인스턴스라고 말할 수 있다.      객체는 인스턴스의 묶음이라고 볼 수 있다.        ✔️ 런타임컴퓨터 과학에서 컴퓨터 프로그램이 실행되고 있는 동안의 동작/* 객체와 인스턴스 */public class Main {public static void main(String[] args) {Phone Galaxy20, IPhone11; // '객체'    // 인스턴스화    Galaxy20 = new Phone(); // Galaxy20은 Phone 클래스의 '인스턴스'(객체를 메모리에 할당)    IPhone11 = new Phone(); // IPhone11은 Phone 클래스의 '인스턴스'(객체를 메모리에 할당)  }}4. 비교4-1. 클래스(Class) VS 객체(Object)            클래스      객체                  ‘설계도’      ‘설계도로 구현한 모든 대상’      4-2. 객체(Object) VS 인스턴스(Instance)클래스의 타입으로 선언되었을 때 객체라고 부르고, 그 객체가 메모리에 할당되어 실제 사용될 때 인스턴스라고 부른다.            객체      인스턴스                  현실 세계에 가깝다.      소프트웨어 세계에 가깝다.              ‘실체’에 초점      인스턴스는 ‘관계’에 초점              ‘클래스의 인스턴스’      ‘방금 인스턴스화하여 레퍼런스를 할당한’ 객체  : 이는 원본(추상적인 개념)으로부터 생성되었다는 것에 의미를 부여하는 것일 뿐 엄격하게 객체와 인스턴스를 나누긴 어렵다.      4-3. 클래스(Class) VS 인스턴스(Instance)            클래스      인스턴스                  객체를 만들어 내기 위한 설계도      설계도인 클래스를 바탕으로 구현된구체적인 실체              실체가 없음      구체적인 실체      4-4. 클래스(Class) VS 객체(Object) VS 인스턴스(Instance)            객체      실세계의 엔티티(Entity)를 대표한다.              인스턴스      소프트웨어에서 활동하는 객체의 실재이다.              클래스      실세계의 엔티티를 추상화한 속성과 기능을 가지며 객체를 생성하기 위한 생성자를 제공한다.      (참고링크)  클래스의 개념  [Java] 클래스, 객체, 인스턴스의 차이  클래스(class), 객체(Object), 인스턴스(Instance)의 차이점. [ Java &amp; OOP 면접 질문1]  클래스, 객체, 인스턴스 차이 구분  [자바, Java] 클래스(class), 객체(object), 인스턴스(instance) 차이 공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다. 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. "
  },
  
  {
    "title": "/JPA/ 즉시로딩, 지연로딩",
    "url": "/posts/eager-lazy/",
    "categories": "03.STUDY, JPA",
    "tags": "STUDY",
    "date": "2023-01-23 00:00:00 +0900",
    





    
    "snippet": "  fetch의 디폴트 값-@xxToOne: EAGER-@xxToMany: LAZY1. 즉시로딩EAGER LOADING@xxToxx(fetch = fetchType.EAGER)  엔티티를 조회할 때 연관된 엔티티도 함께 조회(= 연관된 엔티티를 즉시조회)  하이버네이트는 가능하면 SQL조인을 사용해서 한번에 조회(JPA 구현체는 즉시 로딩을 최적화하기...",
    "content": "  fetch의 디폴트 값-@xxToOne: EAGER-@xxToMany: LAZY1. 즉시로딩EAGER LOADING@xxToxx(fetch = fetchType.EAGER)  엔티티를 조회할 때 연관된 엔티티도 함께 조회(= 연관된 엔티티를 즉시조회)  하이버네이트는 가능하면 SQL조인을 사용해서 한번에 조회(JPA 구현체는 즉시 로딩을 최적화하기 위해 가능하면 조인쿼리를 사용)  장점          지연된 초기화와 관련해서 성능적인 영향이 없음      즉시 로딩(Earge Loading)        단점          지연 로딩보다 긴 초기의 로딩 시간이 필요함      불필요한 데이터를 많이 로딩하면 성능에 영향을 줄 수 있음        ✔️하이버네이트-자바 언어를 위한 ORM 프레임워크이고 JPA의 구현체로,　 JPA 인터페이스를 구현하고 내부적으로 JDBC API를 사용한다.-자바객체를 통해 데이터베이스가 Oracle, MySql, MSSQL 등에 상관없이　 다룰수 있도록 하는 추상화를 목표로 한다.2. 지연로딩LAZY LOADING@xxToxx(fetch = fetchType.LAZY)  엔티티를 조회할 때 연관된 엔티티는 프록시로 조회되며,프록시를 실제 사용할 때 초기화되면서 데이터베이스를 조회  가급적이면 기본적으로 지연 로딩을 사용하는 것이 좋다.  장점          다른 접근 방식보다 훨씬 적은 초기의 로딩 시간      다른 접근 방식에 비해 메모리 소비량 감소      지연 로딩(Lazy Loading)        단점          초기화가 지연되면 원하지 않는 순간 성능에 영향을 줄 수 있음        ✔️ 프록시-클라이언트가 이를 통해서 통해서 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해 주는 컴퓨터 시스템이나 응용 프로그램-서버와 클라이언트 사이에 중계기로서 대리로 통신을 수행하는 것을 가리켜 ‘프록시’,  그 중계 기능을 하는 것을 프록시 서버라고 부른다.3. 언제 사용하면 좋은가  즉시로딩          쿼리문을 두 번 따로 사용하여 조회하지 않고연관된 엔티티를 즉시 조회하는 게 더 유리할 때 사용하면 좋다.        지연 로딩          필요한 시점에 연관된 엔티티를 조회하여 로딩 시간을 줄이고,불필요한 쿼리문 사용을 방지할 수 있어가급적이면 기본적으로 지연 로딩을 사용하는 것이 좋다.      4. 주의할 점  즉시로딩을 적용하면 예상하지 못한 SQL이 발생할 수 있음  즉시로딩은 JPQL에서 N+1 문제를 일으킴  즉시로딩의 큰 문제는 성능 최적화가 어렵다는 점➡️ 가급적이면 지연 로딩(Lazy Loading)만 사용하고,　　 성능 최적화가 꼭 필요한 곳에는 JPQL 페치 조인을 사용하는 것이 좋다.기본값이 즉시로딩음 @–ToOne을 fetch = FetchType.LAZY로 설정해지연 로딩 전략을 사용하도록 변경하는 것이 좋다.(참고링크)  [JPA] 즉시 로딩과 지연 로딩(FetchType.LAZY or EAGER)  JPA 지연로딩을 사용해야하는 이유, 지연로딩(Lazy)과 즉시로딩(Eager)  하이버네이트(Hidernate) 설명 및 설정법  Spring Data JPA 즉시 로딩(Eager Loading) &amp; 지연 로딩(Lazy Loading) 공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다. 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. "
  },
  
  {
    "title": "/Database/ SQL",
    "url": "/posts/sql/",
    "categories": "03.STUDY, Database",
    "tags": "STUDY",
    "date": "2023-01-23 00:00:00 +0900",
    





    
    "snippet": "whrer : 조건group by : ~별order by : 정렬Group by동일한 범주의 개수 구하기select [범주별로 세어주고 싶은 필드명], count(*) from [테이블명]group by [범주별로 세어주고 싶은 필드명];동일한 범주에서의 최솟값 구하기select [범주가 담긴 필드명], min(:최솟값을 알고 싶은 필드명) from ...",
    "content": "whrer : 조건group by : ~별order by : 정렬Group by동일한 범주의 개수 구하기select [범주별로 세어주고 싶은 필드명], count(*) from [테이블명]group by [범주별로 세어주고 싶은 필드명];동일한 범주에서의 최솟값 구하기select [범주가 담긴 필드명], min(:최솟값을 알고 싶은 필드명) from [테이블명]group by [범주가 담긴 필드명];동일한 범주에서의 최댓값 구하기select [범주가 담긴 필드명], max(:최댓값을 알고 싶은 필드명) from [테이블명]group by [범주가 담긴 필드명];동일한 범주의 평균 구하기select [범주가 담긴 필드명], avg(:평균값을 알고 싶은 필드명) from [테이블명]group by [범주가 담긴 필드명];동일한 범주의 합계 구하기select [범주가 담긴 필드명], sum(:합계를 알고 싶은 필드명) from [테이블명]group by [범주가 담긴 필드명];SQL문 연습Select 쿼리문, Where절 연습하기Q. 성이 남씨인 유저의 이메일만 추출하기SELECT email FROM users u WHERE name = '남**'Where절과 자주 같이쓰는 문법 연습하기Q. Gmail을 사용하는 2020/07/12~13에 가입한 유저를 추출하기이외 유용한 문법 연습하기Q. Gmail을 사용하는 2020/07/12~13에 가입한 유저의 수를 세기SELECT * FROM users u WHERE email LIKE \"%gmail.com\" AND created_at BETWEEN '2020-07-12' AND '2020-07-14';1주차 종합Q.  naver 이메일을 사용하면서, 웹개발 종합반을 신청했고 결제는 kakaopay로 이뤄진 주문데이터 추출하기SELECT * FROM ordersWHERE email like '%naver.com'  AND course_title = '웹개발 종합반'  AND payment_method = 'kakaopay';범주의 통계를 내주는 Group byQ. 성씨별 회원수를 Group by로 쉽게 구해보기####Q.####Q.####Q.####Q.####Q.####Q.####Q.####Q.####Q.####Q.####Q.####Q.####Q.####Q.####Q.####Q.####Q.####Q.####Q.####Q.####Q.####Q.####Q.####Q.####Q.####Q.(참고링크) 공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다. 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. "
  },
  
  {
    "title": "✨TIL - 오늘 한 일 / 설연휴 끝",
    "url": "/posts/til-230123/",
    "categories": "01.TIL/WIL, TIL",
    "tags": "TIL",
    "date": "2023-01-23 00:00:00 +0900",
    





    
    "snippet": "오늘 한 일  인텔리제이 연장  SQL 관련 기본강의 완강(4/4)          SQL 관련 기본강의 3/4까지        CS 공부 및 정리 5개          CS 공부 및 정리 1개      설연휴 끝금요일부터 놀고 오늘 다시 돌아왔당. 중간중간 계속 자료구조 책도 읽고, 블로그도 다른 테마로 바꾸었다. 이번엔 이 테마에 정착하고, 블로그...",
    "content": "오늘 한 일  인텔리제이 연장  SQL 관련 기본강의 완강(4/4)          SQL 관련 기본강의 3/4까지        CS 공부 및 정리 5개          CS 공부 및 정리 1개      설연휴 끝금요일부터 놀고 오늘 다시 돌아왔당. 중간중간 계속 자료구조 책도 읽고, 블로그도 다른 테마로 바꾸었다. 이번엔 이 테마에 정착하고, 블로그 꾸미기는 이제 그만… 오늘 좀 늦게 일어나기도 했고, 이동시간때문에 오늘 공부를 많이 못해서 아쉽다. 다시 열심히 공부해야징"
  },
  
  {
    "title": "/etc/ 시간복잡도, 공간복잡도 (+ 빅O 표기법)",
    "url": "/posts/time-space-complexity/",
    "categories": "03.STUDY, etc",
    "tags": "STUDY",
    "date": "2023-01-22 00:00:00 +0900",
    





    
    "snippet": "1. 시간복잡도  알고리즘이 문제를 해결하기 위한 수행시간의 분석 결과인시간,연산의 횟수(스탭수)  주로 최악의 경우(worst case)를 따져 Big O 표기법을 이용해 분석2. 공간복잡도  알고리즘의 메모리 사용량에 대한 분석 결과      주로 최악의 경우(worst case)를 따져 Big O 표기법을 이용해 분석              공간...",
    "content": "1. 시간복잡도  알고리즘이 문제를 해결하기 위한 수행시간의 분석 결과인시간,연산의 횟수(스탭수)  주로 최악의 경우(worst case)를 따져 Big O 표기법을 이용해 분석2. 공간복잡도  알고리즘의 메모리 사용량에 대한 분석 결과      주로 최악의 경우(worst case)를 따져 Big O 표기법을 이용해 분석              공간복잡도가 커졌을 경우?      공간 복잡도는 보통 시간 복잡도보다 중요하게 생각되지 않는 경우가 많다. 그러나 빅데이터 처리를 하는 경우, 공간 복잡도가 위와 같이 커지게 된다면,메모리에 한 번에 올라가지 않아 프로그램을 실행할 수 없는 문제가 발생할 수 있다.이 경우, 데이터를 나눠서 처리하고 다시 합치는 방법을 사용하게 된다.      3. Big O 표기법Big-Oh Notation예를 들어, 동전을 튕겨 뒷면이 나올 확률을 이야기 할 때운이 좋으면 1번에 뒷면이 나오지만 운이 안 좋다면 n번 만큼 동전을 튕겨야 하는 경우가 발생한다.이 최악의 경우를 계산하는 방식을 빅-오(Big-O) 표기법이라 부른다.  알고리즘의 효율성을 상한선 기준으로 표기해주는 표기법          값이 클수록, 그래프가 위로 향할수록 비효율적임을 의미        빅오(Big-O), 빅오메가(big-Ω),빅세타(big-Θ) 표기법      빅오: 상한선 기준    빅오메가: 하한선을 기준    빅세타: 상한선과 하한선의 사이를 기준  3-1. Big-O 표기법의 종류3-1-1. O(1)constant complexity  입력값이 증가하더라도 시간이 늘어나지 않는다.  입력값의 크기와 관계없이, 즉시 출력값을 얻어낼 수 있다.3-1-2. O(n)linear complexity  입력값이 증가함에 따라 시간 또한 같은 비율로 증가      예) 1중 for문    3-1-3. O(log n)logarithmic complexity  O(1) 다음으로 빠른 시간 복잡도를 가짐  예) 자료구조에서 Binary Search Tree　　 ㄴ 2진 탐색트리는 노드를 이동할때마다 경우의 수가 절반으로 줄어든다.3-1-4. O(n^2)quadratic complexity  입력값이 증가함에 따라 시간이 n의 제곱수의 비율로 증가      예) 2중 for문    3-1-5. O(2^n)exponential complexity  Big-O 표기법 중 가장 느린 시간 복잡도를 갖음  O(log n)복잡도 같은 경우는 선택할때마다 경우의 수가 절반으로 줄어들었지만, O (2^n)복잡도는 그 반대로 경우의 수가 2배씩 들어난다.3-2 시간복잡도를 구하는 요령  하나의 루프를 사용하여 단일 요소 집합을 반복 하는 경우 : O (n)  컬렉션의 절반 이상 을 반복 하는 경우 : O (n / 2) -&gt; O (n)  두 개의 다른 루프를 사용하여 두 개의 개별 콜렉션을 반복 할 경우 : O (n + m) -&gt; O (n)  두 개의 중첩 루프를 사용하여 단일 컬렉션을 반복하는 경우 : O (n²)  두 개의 중첩 루프를 사용하여 두 개의 다른 콜렉션을 반복 할 경우 : O (n * m) -&gt; O (n²)  컬렉션 정렬을 사용하는 경우 : O(n*log(n))—*빅-오 표기법 (Big-Oh Notation)O(n)시간복잡도 함수 T(n)T(n)에서 가장 영향력이 큰 부분만을 따지는 표기법*https://lgphone.tistory.com/46(참고링크)  Big O 시간복잡도에 대해서 파악하자!  시간 복잡도와 공간 복잡도 (Time Complexity and Space Complexity) 공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다. 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. "
  },
  
  {
    "title": "/Algorithm/ 이분탐색, 이분탐색의 시간복잡도",
    "url": "/posts/binary-search/",
    "categories": "03.STUDY, Algorithm",
    "tags": "STUDY",
    "date": "2023-01-22 00:00:00 +0900",
    





    
    "snippet": "1. 이분탐색      중간값과 찾으려는 값의 대소를 비교한 뒤탐색 범위를 반으로 줄여가며 값을 찾는 탐색 알고리즘    찾고자 하는 값이 정렬된 배열의 중간 값보다 크면중간값을 포함한 하위 값들은 탐색 대상에서 제외된다.  반대로 찾고자 하는 값이 배열의 중간 값보다 작으면중간 값을 포함한 상위 값들은 탐색에서 제외된다.  장점          처음...",
    "content": "1. 이분탐색      중간값과 찾으려는 값의 대소를 비교한 뒤탐색 범위를 반으로 줄여가며 값을 찾는 탐색 알고리즘    찾고자 하는 값이 정렬된 배열의 중간 값보다 크면중간값을 포함한 하위 값들은 탐색 대상에서 제외된다.  반대로 찾고자 하는 값이 배열의 중간 값보다 작으면중간 값을 포함한 상위 값들은 탐색에서 제외된다.  장점          처음부터 끝까지 돌면서 탐색하는 것보다 훨씬 빠르다.        단점          배열의 중간을 기준으로 데이터를 탐색하기 때문에반드시 데이터가 정렬된 상태로 존재해야 한다.      2. 이분탐색의 시간복잡도이분탐색의 시간복잡도는 logN으로배열을 전수조사하는 O(N)에 비하면 상대적으로 빠른 탐색 알고리즘에 속한다.🔸이분탐색과 선형검색의 시간복잡도 코드/* 이분탐색의 시간복잡도 */static int binSearch(int[] a, int n, int key) {    int pl = 0; // 검색 범위 첫 인덱스    int pr = n –1; // 검색 범위 끝 인덱스    do {        int pc = (pl + pr) / 2; // 중앙 요소의 인덱스        if (a[pc] == key)          return pc; // 검색 성공!        else if (a[pc] &lt; key)          pl = pc + 1; // 검색 범위를 뒤쪽 절반으로 좁힘        else          pr = pc – 1; // 검색 범위를 앞쪽 절반으로 좁힘  } while (pl &lt;= pr);\t  return –1; // 검색 실패!}/*  선형검색의 시간복잡도 */static int seqSearch(int[] a, int n, int key) {int i = 0;while(i &lt; n) { if(a[i] == key) return i; // 검색 성공!  i++;}return –1; // 검색 실패!}🔸시간복잡도 계산법(참고링크)  [Algorithm] 이진 탐색 (이분 탐색, Binary Search) 코드와 시간 복잡도 공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다. 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. "
  },
  
  {
    "title": "❗ERROR - jekyll chirpy theme 자동배포 오류",
    "url": "/posts/0003/",
    "categories": "02.ERROR",
    "tags": "error",
    "date": "2023-01-22 00:00:00 +0900",
    





    
    "snippet": "🧶 Trouble  jekyll chirpy theme 클론받아 수정 후 자동배포를 기다리는데, 404에러 발생과 홈화면이 제대로 실행되지 않는 문제 발생  블로그의 메인페이지에테마의 홈화면이 아닌, index.html 파일 내용이 보임✂️ Shooting깃허브 액션에서 빌드에 실패했다는 에러가 떴고,에러의 내용에 configutation file이 ...",
    "content": "🧶 Trouble  jekyll chirpy theme 클론받아 수정 후 자동배포를 기다리는데, 404에러 발생과 홈화면이 제대로 실행되지 않는 문제 발생  블로그의 메인페이지에테마의 홈화면이 아닌, index.html 파일 내용이 보임✂️ Shooting깃허브 액션에서 빌드에 실패했다는 에러가 떴고,에러의 내용에 configutation file이 없다고 나왔다.레파지토리 settings에 pages에서configure을 누루고 다시 빌드를 시도했더니 성공했다!휴"
  },
  
  {
    "title": "/Java/ Java의 특징",
    "url": "/posts/java/",
    "categories": "03.STUDY, Java",
    "tags": "STUDY",
    "date": "2023-01-20 00:00:00 +0900",
    





    
    "snippet": "JAVA  자바는 객체지향적 프로그래밍 언어(OOP)✔️ 객체지향적 언어(OOP)　프로그래밍에 사용 될 데이터의 상태와 행위를 객체로 만들어,　객체간의 상호작용을 통해 비지니스 로직을 구성하는 프로그래밍 기법입니다.JAVA의 특징  운영체제 독립적이다.          JVM(자바가상머신) 위에서 동작하기 때문에 운영체제에 독립적이다.      JAV...",
    "content": "JAVA  자바는 객체지향적 프로그래밍 언어(OOP)✔️ 객체지향적 언어(OOP)　프로그래밍에 사용 될 데이터의 상태와 행위를 객체로 만들어,　객체간의 상호작용을 통해 비지니스 로직을 구성하는 프로그래밍 기법입니다.JAVA의 특징  운영체제 독립적이다.          JVM(자바가상머신) 위에서 동작하기 때문에 운영체제에 독립적이다.      JAVA는 운영체제나 하드웨어와는 통신하지 않고, JVM과만 통신한다.      JVM은 운영체제 종속적이다.      JAVA는 한번만 작성되어도 어느 운영체제에서도 사용이 가능하다.        객체 지향 언어이다.          기본 자료형을 제외한 모든 요소들이 객체로 표현되어 있다.      객체 지향 개념의 특징인 캡슐화, 상속, 다형성이 잘 적용된 언어입니다.        자동 메모리 관리를 해준다.          가비지 컬렉터가 자동으로 메모리를 관리해준다. (그래서 메모리를 체크,반환하는 일을 해줄 필요가 없다)        네트워크와 분산처리를 지원한다.          자바는 풍부하고 다양한 표준 라이브러리를 제공한다.        멀티쓰레드를 지원한다.          관련 라이브러리를 제공한다.(JAVA API)      여러 쓰레드에 대한 스케줄링은 자바 인터프리터가 담당한다.        동적로딩을 지원한다.          작성한 자바 어플리케이션에 클래스가 여러개여도 모두 로딩하지 않고, 필요할 때마다 로딩하여 사용한다.그래서 변경사항이 발생하여도 전체 어플리케이션을 다시 컴파일하지 않는다.            JVM 위에서 동작하기 때문에 실행 속도가 상대적으로 느리다.        다중 상속이나 타입에 엄격하며, 제약이 많다.  JAVA 접근제한자  자바 접근제어자는 클래스, 인터페이스, 멤버변수, 함수 등의 접근을 제어하는 지시어를 말함  접근제어자를 사용함으로써, 외부 객체의 무분별한 접근으로부터 내부 데이터를 보호할 수 있다.(데이터 무결성)  public :  모든 패키지, 모든 클래스의 접근 허용  protected  : 같은 패키지, 모든 클래스의 접근 허용 (단, 다른 패키지인 경우 자식 클래스의 접근 허용)  default : 같은 패키지 내 클래스만 접근 허용  private : 같은 클래스 내 접근만 허용JAVA 접근제한자를 사용하는 이유객체지향 프로그래밍이란 객체들 간의 상호작용을 코드로 표현하는 것인데,이때 객체들간의 관계에 따라서 접근 할 수 있는 것과 아닌 것, 권한을 구분할 필요가 생긴다.클래스 내부에 선언된 데이터의 부적절한 사용으로부터 보호하기 위해서 접근 제어자를 사용한다.(참고링크)  [백엔드 면접 질문] CS - JAVA 면접 질문 정리(1) 공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다. 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. "
  },
  
  {
    "title": "/Java/ 💚 JVM의 스택과 힙메모리 영역",
    "url": "/posts/JVM-stack-heap/",
    "categories": "03.STUDY, Java",
    "tags": "STUDY",
    "date": "2023-01-19 00:00:00 +0900",
    





    
    "snippet": "JVM의 메모리 할당 방식JVM은 기본적으로 Stack Memory 와 Heap Memory 라 불리는 두가지 저장 공간을 이용해 메모리를 할당한다.이들에 메모리를 할당하는 방법은 바이트 코드를 한 줄 한 줄 읽는 것이다.기본적으로 코드들은 한 줄 한 줄 읽혀서 Stack이라 불리는 공간에 차곡차곡 쌓인다.마지막에 들어온 변수가 먼저 나간다고 해서 L...",
    "content": "JVM의 메모리 할당 방식JVM은 기본적으로 Stack Memory 와 Heap Memory 라 불리는 두가지 저장 공간을 이용해 메모리를 할당한다.이들에 메모리를 할당하는 방법은 바이트 코드를 한 줄 한 줄 읽는 것이다.기본적으로 코드들은 한 줄 한 줄 읽혀서 Stack이라 불리는 공간에 차곡차곡 쌓인다.마지막에 들어온 변수가 먼저 나간다고 해서 LIFO(Last In First Out) 구조를 가진다고도 한다.하지만, 모든 변수를 Stack에 저장할 수 있는 것은 아니다.간단한 변수인 Primitive Type의 변수들은 Stack에 저장이 가능하지만,복잡한 변수는 Heap 공간에 저장되고 Stack에는 해당 Heap 공간을 가리키는 변수가 저장된다.” 변수가 있다면 무조건 Stack에 저장되는데,데이터도 Stack에 저장되는 경우는 간단한 데이터인 경우이며,조금만 복잡해지더라도 Stack에는 변수의 주소값만 저장되고 실제 데이터는 Heap 영역에 저장된다. “JVM의 스택 영역의 특징      정적으로 할당된 메모리 영역        각 스레드마다 하나씩 존재하고 스레드가 시작될 때 생성된다.        변수의 기본형 타입(Primitive 타입) (boolean, char, short, int, long, float, double) 의 데이터가값이랑 같이 할당된다.        int, long, boolean 등 기본 자료형을 생성할 때 저장하는 공간으로,임시적으로 사용되는 변수나 정보들이 저장되는 영역    쓰레드 별로 1개만 생성된다.          하나의 쓰레드는 내부적으로 static, stack, heap 영역을 갖게 됩니다.→ 그래서 A쓰레드는 다른 쓰레드에 접근할 수는 없지만,  static과 heap 영역을 공유하여 사용할 수 있습니다.        메소드가 호출될 때마다 생성하고,메서드 실행이 끝나면 pop되어 제거됩니다.JVM의 힙메모리 영역의 특징      동적으로 할당된 메모리 영역        모든 스레드가 공유하는 영역으로프로그램을 실행하면서 생성된 모든 인스턴스 또는 객체를 저장하는 공간        “new”를 사용하여 객체를 만들 때 저장된다.  Instance instance = new Instance();  -&gt; heap에 존재      Heap 영역에 생성된 Object 타입의 데이터의 참조 값이 할당된다.        참조형(class, interface, enum, Array 등) 자료형도 같이 저장된다.        힙의 참조 주소는 “스택”이 갖고 있고 해당 객체를 통해서만 힙 영역에 있는 인스턴스를 핸들링할 수 있다.        GC가 정리하기 전까지는 남아있습니다.  힙메모리의 한계점Stack은 좁은 메모리 공간이지만, Heap은 넓은 메모리 공간이다.Stack 메모리에 값을 할당하고 해제하는 것은 많은 비용이 들지 않지만, Heap 메모리에 값을 할당하고 해제하는 것은 많은 비용을 요한다.따라서 너무 Heap에 데이터를 자주 할당하고 해제하는 방식으로 코드를 짠다면 같은 방식을 Stack에 했을 때보다 수십배의 속도 차이가 날 수 있다.이 점을 유의하면서 Heap을 사용할 때는 이 점을 유의해서 코드를 짜도록 해야한다.(참고링크)  [JAVA] JAVA 메모리 이야기 - Stack 과 Heap  [Java] 메모리 구조 메소드(Method), 스택(Stack), 힙(Heap) 영역에 대하여  JVM의 Memory 할당 방식 : Stack과 Heap Memory가 동작하는 방법  JVM의 Runtime Data Area  [JAVA] ☕ 그림으로 보는 자바 코드의 메모리 영역(스택 &amp; 힙) 공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다. 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. "
  },
  
  {
    "title": "/Java/ Java가 컴파일되는 과정",
    "url": "/posts/java-compile/",
    "categories": "03.STUDY, Java",
    "tags": "STUDY",
    "date": "2023-01-18 00:00:00 +0900",
    





    
    "snippet": "Java가 컴파일되는 과정  개발자가 .java 파일을 생성한다.  build를 한다.  java compiler의 javac의 명령어를 통해 바이트코드(.class)를 생성한다.  Class Loader를 통해 JVM 메모리 내로 로드(및 링크)하여런타임 영역인 JVM 메모리에 올린다.  JVM에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와 ...",
    "content": "Java가 컴파일되는 과정  개발자가 .java 파일을 생성한다.  build를 한다.  java compiler의 javac의 명령어를 통해 바이트코드(.class)를 생성한다.  Class Loader를 통해 JVM 메모리 내로 로드(및 링크)하여런타임 영역인 JVM 메모리에 올린다.  JVM에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와 실행한다.  실행엔진을 통해 컴퓨터가 읽을 수 있는 기계어로 해석된다.(각 운영체제에 맞는 기계어)(해당 .class파일은 기계어로 번역되게 되는 과정을 거친다.)✔️ 자바 컴파일러(Java compiler)자바 컴파일러는 자바를 가지고 작성한 자바 소스 코드를 자바 가상 머신이 이해할 수 있는 자바 바이트 코드로 변환한다.자바 컴파일러는 자바를 설치하면 javac.exe라는 실행 파일 형태로 설치된다.✔️ 자바 바이트 코드(Java bytecode)자바 바이트 코드(Java bytecode)란 자바 가상 머신이 이해할 수 있는 언어로 변환된 자바 소스 코드를 의미한다.자바 컴파일러에 의해 변환되는 코드의 명령어 크기가 1바이트라서 자바 바이트 코드라고 불리고 있다.이러한 자바 바이트 코드의 확장자는 .class이다.자바 바이트 코드는 자바 가상 머신만 설치되어 있으면, 어떤 운영체제에서라도 실행될 수 있다.✔️ 자바 가상 머신(JVM)자바 가상 머신(JVM, Java Virtual Machine)이란 자바 바이트 코드를 실행시키기 위한 가상의 기계라고 할 수 있다.자바로 작성된 모든 프로그램은 자바 가상 머신에서만 실행될 수 있으므로, 자바 프로그램을 실행하기 위해서는 반드시 자바 가상 머신이 설치되어 있어야 한다.(참고링크)  ..  신입 개발자 기술면접 질문 정리 - 자바 공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다. 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. "
  },
  
  {
    "title": "/Java/ JVM",
    "url": "/posts/JVM/",
    "categories": "03.STUDY, Java",
    "tags": "STUDY",
    "date": "2023-01-18 00:00:00 +0900",
    





    
    "snippet": "📌 JVMJava Virtual Machine  자바가상머신으로 자바 프로그램 실행환경을 만들어 주는 소프트웨어          컴퓨터가 자바 바이트 코드를 운영체제에 맞게 실행시키는 역할      Java와 OS(운영체제) 사이에서 중개자 역할        자바로 작성된 모든 프로그램은 자바 가상 머신에서만 실행될 수 있으므로,자바 프로그램을 실행하...",
    "content": "📌 JVMJava Virtual Machine  자바가상머신으로 자바 프로그램 실행환경을 만들어 주는 소프트웨어          컴퓨터가 자바 바이트 코드를 운영체제에 맞게 실행시키는 역할      Java와 OS(운영체제) 사이에서 중개자 역할        자바로 작성된 모든 프로그램은 자바 가상 머신에서만 실행될 수 있으므로,자바 프로그램을 실행하기 위해서는 반드시 자바 가상 머신이 설치되어 있어야 한다.📌 JVM의 특징  JVM의 역할 : 자바 애플리케이션을 클래스 로더를 통해 읽어 들여 자바 API와 함께 실행한다.  Java가 OS(운영체제)에 구애받지 않고 독립적으로 작동이 가능하다.  Garbage collection(가비지 컬렉션)을 통해 자동적인 메모리 관리를 해준다.  JVM은 스택 기반으로 동작한다.  서로 다른 운영체제라도 자바 가상 머신만 설치되어 있다면,같은 자바 프로그램이 아무런 추가 조치 없이 동작할 수 있다.  개발자는 한 번만 프로그램을 작성하면, 모든 운영체제에서 같이 사용할 수 있는 장점이 있다.  단, 자바 프로그램과는 달리 자바 가상 머신(JVM)은 운영체제에 종속적이므로,각 운영체제에 맞는 자바 가상 머신을 설치해야 한다.  자바 프로그램은 일반 프로그램보다 자바 가상 머신이라는 한 단계를 더 거쳐야 하므로,상대적으로 실행 속도가 느리다는 단점을 가지고 있다.📌 JVM 구조1. Class Loader  클래스 파일을 Runtime Data Area의 메서드 영역으로 불러오는 역할을 한다.  JVM 내로 클래스 파일을 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈입니다.  런타임 시에 동적으로 클래스를 로드합니다.2. Execution Engine(실행엔진)  .class파일과 같은 ByteCode를 실행 가능하도록 해석한다.3. Garbage Collector(GC)  메모리 관리 기법 중 하나로, Heap 영역에 배치된 객체들을 관리하는 모듈이다.4. Runtime Data Area  런타임 시 클래스 데이터와 같은 메타 데이터와 실제 데이터가 저장되는 곳이다.  간단하게 말하자면 프로그램을 수행하기 위해 OS로부터 할당받은 메모리 영역을 의미한다. (Java 메모리 공간)  Runtime Data Area은 또다시 이렇게 나누어진다.          Method Area      Heap      PC Registers      Java Stacks      Native Method Stacks      📌 JVM의 작동원리자바 소스 파일은 자바 컴파일러에 의해서 바이트 코드 형태인 클래스 파일이 됩니다. 그리고 이 클래스 파일은 클래스 로더가 읽어들이면서 JVM이 수행됩니다.      자바로 개발된 프로그램을 실행하면 JVM은 OS로부터 메모리를 할당합니다.        자바 컴파일러(javac)가 자바 소스코드(.java)를 자바 바이트코드(.class)로 컴파일합니다.        Class Loader를 통해 JVM Runtime Data Area로 로딩합니다.        Runtime Data Area에 로딩 된 .class들은 Execution Engine을 통해 해석합니다.        해석된 바이트 코드는 Runtime Data Area의 각 영역에 배치되어 수행하며 이 과정에서 Execution Engine에 의해 GC의 작동과 스레드 동기화가 이루어집니다.  📌 JVM이 필요한 이유JVM은자바 바이트코드를 실행할 수 있는 환경을 제공해주고,이를 통해 자바 바이트 코드가플랫폼에 독립적으로 어디서든 실행될 수 있게 되어OS에 상관없이 어디서든 JAVA 애플리케이션을 실행할 수 있게 해주기 때문에 사용한다.(참고링크)  신입 개발자 기술면접 질문 정리 - 자바  [IT 기술 면접] JVM (자바 가상 머신) 이란?  [Java] 자바 가상머신 JVM(Java Virtual Machine) 총정리  JVM &amp; 메모리 구조  JVM의 Runtime Data Area  CS 면접 준비[백엔드 면접 질문] CS - JAVA 면접 질문 정리(1)  자바 프로그래밍 공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다. 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. "
  },
  
  {
    "title": "/etc/ 동기&비동기, 블록킹&논블록킹",
    "url": "/posts/synchronous-blocking/",
    "categories": "03.STUDY, etc",
    "tags": "STUDY",
    "date": "2023-01-17 00:00:00 +0900",
    





    
    "snippet": "  동기 &amp; 비동기 : 프로세스의 수행 순서 보장에 대한 매커니즘          동기 : 작업을 동시에 수행하거나, 동시에 끝나거나, 끝나는 동시에 시작      비동기 : 시작, 종료가 일치하지 않으며, 끝나는 동시에 시작을 하지 않음        블록킹 &amp; 논블록킹 : 프로세스의 유휴 상태에 대한 개념          블록킹 : 자...",
    "content": "  동기 &amp; 비동기 : 프로세스의 수행 순서 보장에 대한 매커니즘          동기 : 작업을 동시에 수행하거나, 동시에 끝나거나, 끝나는 동시에 시작      비동기 : 시작, 종료가 일치하지 않으며, 끝나는 동시에 시작을 하지 않음        블록킹 &amp; 논블록킹 : 프로세스의 유휴 상태에 대한 개념          블록킹 : 자신의 작업을 진행하다가 다른 주체의 작업이 시작되면　　　　　다른 작업이 끝날 때까지 기다렸다가 자신의 작업을 시작하는 것      논블록킹 : 다른 주체의 작업에 관련없이 자신의 작업을 하는 것      동기Synchronous  서버에서 요청을 보냈을 때 응답이 돌아와야 다음 동작을 수행할 수 있는 방식(A작업이 모두 진행 될때까지 B작업은 대기해야한다.)  요청과 결과가 한 자리에서 동시에 일어난다.  A노드와 B노드 사이의 작업 처리 단위(transaction)를 동시에 맞춘다.  장점:설계가 매우 간단하고 직관적  단점:결과가 주어질 때까지 아무것도 못하고 대기해야 한다.비동기Asynchronous  반대로 요청을 보냈을 때응답 상태와 상관없이 다음 동작을 수행 할 수 있는 방식(A작업이 시작하면 동시에 B작업이 실행된다. A작업은 결과값이 나오는대로 출력된다.)  비동기적 코드의 실행 결과는동기적 코드가 전부 실행 되고나서 값을 반환한다.  노드 사이의 작업 처리 단위를 동시에 맞추지 않아도 된다.  장점:결과가 주어지는데 시간이 걸리더라도 그 시간 동안에 다른 작업을 할 수 있으므로  자원들을 효율적으로 사용 할 수 있다.  단점:동기보다 복잡한 설계블로킹Blocking  A함수가 B함수를 호출하면 B에게 제어권을 넘긴다.  제어권을 넘겨받은 B는 열심히 함수를 실행한다. A는 B에게 제어권을 넘겨주었기 때문에 함수 실행을 잠시 멈춘다.  B함수는 실행이 끝나면 자신을 호출한 A에게 제어권을 돌려준다.논블로킹Non-Blocking  A함수가 B함수를 호출하면, B 함수는 실행되지만, 제어권은 A 함수가 그대로 가지고 있는다.  A함수는 계속 제어권을 가지고 있기 때문에 B함수를 호출한 이후에도 자신의 코드를 계속 실행한다.동기&amp;비동기 + 블로킹&amp;논블로킹 조합(참고링크)  동기, 비동기  동기, 비동기 처리  109dev 2021. 1. 15.  [Java]동기와 비동기 방식(Asynchronous processing model)  [10분 테코톡] 🎧 우의 Block vs Non-Block &amp; Sync vs Async  [운영체제] 동기와 비동기, 블로킹과 논블로킹  동기/비동기 vs 블로킹/논블로킹  블로킹(Blocking)과 논 블로킹(Non-Blocking)이란 무엇인가?!  동기 &amp; 비동기 / 블로킹 &amp; 논블로킹 💯 완벽 이해하기 공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다. 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. "
  },
  
  {
    "title": "/etc/ Base64",
    "url": "/posts/base64/",
    "categories": "03.STUDY, etc",
    "tags": "STUDY",
    "date": "2023-01-16 00:00:00 +0900",
    





    
    "snippet": "Base64 인코딩  8비트 Binary Data(2진 데이터:zip파일이나 exe파일 등)를문자 코드에 영향을 받지 않는 공통 ASCII 영역의 문자들을 6bit씩 끊어서일련의 문자열로 바꾸는 인코딩 방식  이는 데이터가 전송 중에 수정 없이 그대로 유지되도록 하기 위한 것이다.  일반적으로 MIME을 통한 이메일 및 XML로 복잡한 데이터 저장을 ...",
    "content": "Base64 인코딩  8비트 Binary Data(2진 데이터:zip파일이나 exe파일 등)를문자 코드에 영향을 받지 않는 공통 ASCII 영역의 문자들을 6bit씩 끊어서일련의 문자열로 바꾸는 인코딩 방식  이는 데이터가 전송 중에 수정 없이 그대로 유지되도록 하기 위한 것이다.  일반적으로 MIME을 통한 이메일 및 XML로 복잡한 데이터 저장을 비롯한 여러 애플리케이션에서 사용됩니다.✔️인코딩(encoding)　:정보의 형태나 형식을(표준화, 보안, 처리 속도 향상, 저장 공간 절약 등을 위해서)　다른 형태나 형식으로 변환하는 것　✔️인코딩을 하는 이유　:데이터의 표준화, 처리 속도 향상, 저장 공간 절약, 보안 등Base64를 사용하는 이유문자를 전송하기 위해서는 설계된 미디어(email, html)을 통해독립적으로 바이너리 데이터를 전송할 필요가 있을 때ASCII로 인코딩하여 전송하게 되면 문제가 발생할 수 있다.이때 Base64는ASCII의 제어문자와 일부 특수문자를 제외한64개의 안전한 출력 문자만 사용해시스템간 데이터를 전달해 더 안전하다.비록 encoding 함으로써 전달할 데이터가 더 길어지긴 하지만 데이터가 왜곡되지 않기 때문이다.(참고링크)  base64  base64 인코딩을 사용하는 이유 공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다. 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. "
  },
  
  {
    "title": "/Database/ HTTP, HTTPS",
    "url": "/posts/http-https/",
    "categories": "03.STUDY, Database",
    "tags": "STUDY",
    "date": "2023-01-16 00:00:00 +0900",
    





    
    "snippet": "📌 HTTPHyperText Transfer Protocol  인터넷 상에서 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약  서버/클라이언트 모델을 따라 데이터를 주고 받기 위한 프로토콜 (80번 포트를 사용)  인터넷을 작동시키는 역할을 하며, 웹 서버 및 웹 브라우저 상호 간의 데이터 전송을 위한 응용계층 프로토콜입니다.✔️프로토콜-컴퓨...",
    "content": "📌 HTTPHyperText Transfer Protocol  인터넷 상에서 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약  서버/클라이언트 모델을 따라 데이터를 주고 받기 위한 프로토콜 (80번 포트를 사용)  인터넷을 작동시키는 역할을 하며, 웹 서버 및 웹 브라우저 상호 간의 데이터 전송을 위한 응용계층 프로토콜입니다.✔️프로토콜-컴퓨터 내부에서, 또는 컴퓨터 사이에서　데이터의 교환 방식을 정의하는 규칙 체계-기기 간 통신은 교환되는 데이터의 형식에 대해 상호 합의를 요구함  HTTP는 암호화가 되지 않은 평문 데이터를 전송하는 프로토콜이였기 때문에,  HTTP로 비밀번호나 주민등록번호 등을 주고 받으면 제3자가 정보를 조회할 수 있었다.➡️ 그리고 이러한 문제를 해결하기 위해 HTTPS가 등장하게 되었다.HTTP 1 / HTTP 2HTTP1은 기본적으로 연결당 하나의 요청/응답을 처리하여 다음과 같은 문제를 가지고 있었다.  HOL(Head Of Line) Blocking (특정 응답 지연):클라이언트의 요청과 서버의 응답이 동기화되어 지연 발생  RTT(Round Trip TIme) 증가 (양방향 지연):패킷 왕복 시간의 지연 발생  헤더 크기의 비대:쿠키 등과 같은 메타데이터에 의해 헤더가 비대해짐그리고 HTTP2는 다음과 같은 기술을 사용하여 HTTP1의 성능 문제를 해결하였다.  Multiplexed Streams:하나의 커넥션으로 여러 개의 메세지를 동시에 주고 받을 수 있음  Stream Prioritization:요청온 리소스간의 의존관계를 설정하여 먼저 응답해야하는 리소스를 우선적으로 반환함  Header Compression:헤더 정보를 HPACK 압축 방식을 이용하여 압축 전송함  Server Push:HTML문서 상에 필요한 리소스를 클라이언트 요청없이 보내줄 수 있음HTTP의 구조  애플리케이션 레벨의 프로토콜로 TCP/IP 위에서 작동한다.  상태를 가지고 있지 않는 Stateless 프로토콜이다.  Method, Path, Version, Headers, Body 등으로 구성된다.  시작 줄(start-line):HTTP 요청 / 또는 요청에 대한 성공 또는 실패가 기록된다. 항상 한 줄로 끝난다.  HTTP 헤더:시작 줄 다음으로 요청에 대한 설명 / 또는 메시지 본문에 대한 설명이 들어간다.  빈 줄:요청에 대한 모든 메타 정보가 전송되었음을 알리는 빈 줄이 삽입된다. (헤드와 본문 사이)  본문(optional):요청과 관련된 데이터(HTML form 콘텐츠 등) / 또는 응답과 관련된 문서(document)가 선택적으로 들어간다. 본문의 존재와 크기는 시작 줄 및 HTTP 헤더에 명시된다.HTTP 메시지의 시작 줄과 HTTP 헤더를 묶어서 요청 헤드(head) 라고 부르며,이와 반대로 HTTP 메시지의 페이로드는 본문(body) 이라고 한다.📌 HTTPSHypertext Transfer Protocol Secure(HyperText Transfer Protocol over Secure Socket Layer, HTTP over TLS, HTTP over SSL, HTTP Secure 등)  HTTP에 데이터 암호화가 추가된 프로토콜 (443번 포트를 사용)  인터넷 상에서 정보를 암호화하는 SSL 프로토콜을 사용해 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약  표준 HTTP와 동일한 방식으로 작동하지만,서버와 주고받는 데이터가 암호화되기 때문에 웹사이트에 추가적인 보호를 제공한다.  개인 데이터를 훔치거나, 해킹하거나 볼 수 없도록 작동한다.  네트워크 상에서 중간에 제3자가 정보를 볼 수 없도록 암호화를 지원하고 있다.✔️HTTPS 확인 방법-브라우저에서 URL을 확인하여 웹사이트에 HTTPS 보호 기능이 있는지를 확인할 수 있음-도메인 이름 앞에 자물쇠 아이콘이 있으면 당신의 사이트는 HTTPS로 인해 안전한 것📌 HTTPS가 더 안전한 원리  SSL/TLS 프로토콜을 사용하여 공격자가 데이터를 도용할 수 없도록 통신을 암호화 해준다.  웹사이트 서버가 누구인지 확인하여명의 도용을 방지해주어 더 안전하게 사용할 수 있게 해준다.SSL/TLS(Secure Sockets Layer)SSL(Secure Socket Layer)TLS(Transport Layer Security)  암호화 기반 인터넷 보안 프로토콜  안전한 계층(layer)을 웹 통신에 추가하는 방식  TLS는 SSL의 개선 버전으로,최신 인증서는 대부분 TLS를 사용하지만, 편의적으로 SSL 인증서라고 말한다.  이 기술을 수행하기 위해 웹 서버에 설치하는 것이 SSL/TLS 인증서이다.  웹 브라우저는 공신력 있는 인증서의 정보를 브라우저 내부에 보관하고 있으며,접속하는 웹 사이트에 믿을만한 인증서가 설치되어 있는지 확인한다.📌 HTTPS 연결 과정HTTP는 평문 데이터를 전송하는 프로토콜이기 때문에, HTTP로 비밀번호나 주민번호 등을 주고 받으면 제3자에 의해 조회될 수 있습니다. 이러한 문제를 해결하기 위해 HTTP에 암호화가 추가된 프로토콜이 HTTPS입니다.HTTPS에는 대칭키 암호화와 비대칭키 암호화가 모두 사용됩니다. 비대칭키 암/복호화는 비용이 매우 크기 때문에 서버와 클라이언트가 주고받는 모든 메세지를 비대칭키로 암호화하면 오버헤드가 발생할 수 있습니다. 그래서 서버와 클라이언트가 최초 1회로 서로 대칭키를 공유하기 위한 과정에서 비대칭키 암호화를 사용하고, 이후에 메세지를 주고 받을 때에는 대칭키 암호화를 사용합니다. 이러한 과정을 정리하면 다음과 같습니다.  클라이언트(브라우저)가 서버로 최초 연결 시도를 함  서버는 공개키(엄밀히는 인증서)를 브라우저에게 넘겨줌  브라우저는 인증서의 유효성을 검사하고 세션키를 발급함  브라우저는 세션키를 보관하며 추가로 서버의 공개키로 세션키를 암호화하여 서버로 전송함  서버는 개인키로 암호화된 세션키를 복호화하여 세션키를 얻음  클라이언트와 서버는 동일한 세션키를 공유하므로 데이터를 전달할 때 세션키로 암호화/복호화를 진행함📌 HTTP를 사용하면 무조건 안전한가?HTTPS도 무조건 안전한 것은 아니다.(신뢰받는 CA 기업이 아닌 자체 인증서 발급한 경우 등)이때는 HTTPS지만 브라우저에서 주의 요함, 안전하지 않은 사이트와 같은 알림으로 주의 받게 된다.HTTPS는 웹에서 보안을 적용하기 위한 가장 기본적인 단계이고, 이것으로 모든 보안성이 완벽하게 지켜졌다고 할 순 없다.예를 들면, 웹 서버가 해커의 다양한 공격에 의해 루트 권한을 탈취당했다면, 모든 기밀 데이터를 열람할 수 있는 권한이 넘어갈 수도 있다. 또한 HTTPS는 전달 구간에 대한 보안 기술인데, 전달 구간 중간에 해커가 중간자 공격을 수행할 수 있는 취약점이 있다면 HTTPS는 유지되지만 전달하는 내용은 고스란히 노출되기 때문이다.따라서 인스턴트 메시징 서비스와 같이 개인 간 혹은 그룹 간 대화, 민감한 개인 정보 등의 전달에서는 HTTPS를 적용하면서도, 종단 간 암호화 기술을 추가로 적용하여 HTTPS가 무력화되어도 노출된 데이터는 암호화를 유지해, 외부로 노출되지 않도록 하는 방법이 일반적으로 쓰인다.(참고링크)  [Web] HTTP와 HTTPS의 개념 및 차이점  HTTP HTTPS 차이: 당신의 웹 사이트는 안전한가요?  HTTP &amp; HTTPS  Http와 Https 이해와 차이점 그리고 오해(?)  안전한 웹을 위해 HTTPS 이해하기: ①HTTPS의 작동 원리,요즘IT  7계층 HTTP 프로토콜  네트워크/HTTP 모의면접 질문 리스트  HTTPS와 HTTP의 차이점. 핵심은 SSL/TLS [ 네트워크 면접질문 6 ]  [기술면접] CS 기술면접 질문 - 네트워크 (4/8)    HTTP 공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다. 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. "
  },
  
  {
    "title": "/Spring/ Transaction",
    "url": "/posts/transaction/",
    "categories": "03.STUDY, Spring",
    "tags": "STUDY",
    "date": "2023-01-15 00:00:00 +0900",
    





    
    "snippet": "📌 트랜잭션  Transactional이란 어노테이션은데이터베이스의 상태를 변경하는 작업 또는 한번에 수행되어야 하는 연산들을 의미  예외 발생 시 rollback 처리를 자동으로 수행해주는 어노테이션  ACID라 하는 네가지 특성을 가지고 있습니다.✔️상태를 변경시킨다는 것= SQL 질의어를 통해 DB에 접근하는 것-SELECT-INSERT-DELE...",
    "content": "📌 트랜잭션  Transactional이란 어노테이션은데이터베이스의 상태를 변경하는 작업 또는 한번에 수행되어야 하는 연산들을 의미  예외 발생 시 rollback 처리를 자동으로 수행해주는 어노테이션  ACID라 하는 네가지 특성을 가지고 있습니다.✔️상태를 변경시킨다는 것= SQL 질의어를 통해 DB에 접근하는 것-SELECT-INSERT-DELETE-UPDATE트랜잭션의 4가지 조건(ACID)  원자성(Atomicity)          한 트랜잭션 내에서 실행한 작업들은 하나의 단위로 처리한다.  (모두 성공 또는 모두 실패)      트랜잭션이 DB에 모두 반영되거나, 혹은 전혀 반영되지 않아야 된다.        일관성(Consistency)          트랜잭션은 일관성 있는 데이터베이스 상태를 유지한다.  (data integrity 만족 등)      트랜잭션의 작업 처리 결과는 항상 일관성 있어야 한다.        격리성/독립성/고립성(Isolation)          동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않도록 격리해야 한다.      둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 때, 어떤 트랜잭션도 다른 트랜잭션 연산에 끼어들 수 없다.        영속성/지속성(Durability)          트랜잭션을 성공적으로 마치면 결과가 항상 저장되어야 한다.      트랜잭션이 성공적으로 완료되었으면, 결과는 영구적으로 반영되어야 한다.      트랜잭션의 사용시 발생할 수 있는 문제점      현금 인출기를 작동하는 도중에 기계오류나 정전 등과 같은 예기치 않은 상황이 발생하여 카드가 나오지 않거나 기계가 멈추는 경우        각 각 다른 지점의 은행에서 동시에 인출할 때, 하나의 지점이 다른지점에서 저장한 잔액을 덮어 쓰는 경우  위와 같은 상황이 발생되지 않도록 방지하기 위해,즉 트랜잭션의 성질인 ACID 를 제공받기위해 트랜잭션을 사용한다트랜잭션의 상태  활동 (Active)          트랜잭션이 실행 중에 있는 상태, 연산들이 정상적으로 실행 중인 상태        장애 (Failed)          트랜잭션이 실행에 오류가 발생하여 중단된 상태        철회 (Aborted)          트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태        부분 완료 (Partially Committed)          트랜잭션이 마지막 연산까지 실행했지만, Commit 연산이 실행되기 직전의 상태        완료 (Committed)          트랜잭션이 성공적으로 종료되어 Commit 연산응 실행한 후의 상태      트랜잭션의 연산하나의 트랜잭션은 commit 되거나, rollback 된다.  Commit          하나의 트랜잭션이 성공적으로 끝났고, DB가 일관성있는 상태일 때 이를 알려주기 위해 사용하는 연산      트랜잭션 안의 작업 내용 반영 (INSERT, UPDATE, DELETE …)        Rollback          하나의 트랜잭션 처리가 비정상적으로 종료되어 트랜잭션 원자성이 깨진 경우이 트랜잭션의 일부가 정상적으로 처리되었더라도트랜잭션의 원자성을 구현하기 위해 이 트랜잭션이 행한 모든 연산을 취소(undo)하는 연산      transaction이 정상적으로 종료되지 않았을 때,last consistent state(Transaction의 시작 상태 등)로 roll back 할 수 있음.      트랜잭션 안의 작업 내용 반영안함 (INSERT, UPDATE, DELETE …)      트랜잭션의 전파속성Propagation(전파속성)Spring이 제공하는 선언적 트랜잭션(트랜잭션 어노테이션, @Transactional)의 장점 중 하나는 여러 트랜잭션을 묶어서 커다란 하나의 트랜잭션 경계를 만들 수 있다는 점이다. 작업을 하다보면 기존에 트랜잭션이 진행중일 때 추가적인 트랜잭션을 진행해야 하는 경우가 있다.  이미 트랜잭션이 진행중일 때 추가 트랜잭션 진행을 어떻게 할지 결정하는 것이 전파 속성(Propagation)이다.전파 속성에 따라 기존의 트랜잭션에 참여할 수도 있고,별도의 트랜잭션으로 진행할 수도 있고,에러를 발생시키는 등 여러 선택을 할 수 있다.이렇게 하나의 트랜잭션이 다른 트랜잭션을 만나는 상황을 그림으로 나타내면 다음과 같다.트랜잭션의 격리수준Isolation(격리수준, 고립레벨)트랜잭션 격리가 성공하는 정도의 측정값을 말한다.(SQL 의 Isolation level 과 동일하게 동작)  [Level 0] Read Uncommitted          commit 되지 않은 데이터를 읽는다.      select 수행하는 동안 해당 데이터에 Shared lock이 걸리지 않는다.        [Level 1] Read Committed          commit 된 데이터만 읽는다.      select 수행하는 동안 해당 데이터에 Shared lock이 걸린다.        [Level 2] Repeatable Read          자신의 트랜잭션이 생성되기 이전의 트랜잭션(낮은 번호의 트랜잭션)의 커밋된 데이터만 읽는다.      트랜잭션이 완료될 때까지 해당 데이터 수정이 불가능하다.        [Level 3] Serializable          LOCK 을 걸고 사용      트랜잭션이 완료될 때까지 해당 데이터 수정, 입력이 불가능하다.        DEFAULT : 사용하는 DB 기본 설정을 따른다. (Oracle 은 READ_COMMITED, Mysql InnoDB 는 REPEATABLE_READ 가 Default)(참고링크)  DB 트랜잭션(Transaction)    DBMS는 어떻게 트랜잭션을 관리할까?  03. 기술 면접 - 데이터베이스 - 트랜잭션  [Spring] 스프링의 트랜잭션 전파 속성(Transaction propagation) 완벽하게 이해하기  트랜잭션 전파 속성 ( propagation ), 롤백 예외  back/Spring Framework @Transactional Propagation (전파속성), Isolation (격리수준레벨) 그리고 synchronized  [Spring/DB] @Transactional의 전파 속성과 고립 레벨  Transaction 전파가 뭡니까? 공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다. 참고링크는 맨 아래 있습니다. 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. "
  },
  
  {
    "title": "/JPA/ JPA의 더티체킹",
    "url": "/posts/dirty-checking/",
    "categories": "03.STUDY, JPA",
    "tags": "STUDY",
    "date": "2023-01-15 00:00:00 +0900",
    





    
    "snippet": " 공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다. 참고링크는 맨 아래 있습니다. 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. JPA(Java Persistence API)를 사용하면서 더티 체킹과 트랜잭션의 관계에 대해서 알고 있지 않으면,비즈니스 로직에서 다루는 엔티티 데이터가 꼬이는 경우가 발생할 수 있다.데이터가...",
    "content": " 공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다. 참고링크는 맨 아래 있습니다. 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. JPA(Java Persistence API)를 사용하면서 더티 체킹과 트랜잭션의 관계에 대해서 알고 있지 않으면,비즈니스 로직에서 다루는 엔티티 데이터가 꼬이는 경우가 발생할 수 있다.데이터가 꼬이는 경우를 방지하려면,더티 체킹(Dirty Checking)이 어떤 상황에 사용이 되는지 알고 있어야 한다.JPA 더티체킹dirty checking  JPA에서 엔티티 매니저는 엔티티를 저장/조회/수정/삭제를 하는데,수정에 해당하는 메서드가 없고, 대신해서 더티체킹을 지원한다.  더티 체킹이란 “상태 변경 검사” 또는 “변경감지”라고 한다.  Transaction 안에서 엔티티의 변경이 일어나면,변경 내용을 자동으로 데이터베이스에 반영하는 JPA 특징이다.(변경은 최초 조회 상태가 기준이다)  *Dirty: 엔티티 데이터의 변경된 부분*Dirty Checking : 변경된 부분을 체크해서 DB에 반영한다.  ✔️ 데이터베이스에 변경 데이터를 저장하는 시점-Transaction commit 시점-EntityManager flush 시점-JPQL 사용 시점더티체킹이 일어나는 환경  영속 상태(Managed) 안에 있는 엔티티인 경우  Transaction 안에서 엔티티를 변경하는 경우더티체킹의 과정  트랜잭션을 커밋하면 엔티티 매니저 내부에서 먼저 플러시(flush())가 호출된다.  엔티티와 스냅샷을 비교해서 변경된 엔티티를 찾는다.  변경된 엔티티가 있으면 수정쿼리를 생성해서 쓰기 지연 SQL 저장소에 보낸다.  쓰기 지연 저장소의 SQL을 데이터베이스에 보낸다.  데이터베이스 트랜잭션을 커밋한다.  update 쿼리는 없지만, save() 메서드로 저장하지 않아도 더티체킹으로 update 쿼리가 실행되어 update 쿼리가 데이터베이스로 전달된다.더티체킹의 특징            더티체킹의 대상      영속성 컨택스트(Persistence Context) 안에 있는 엔티티를 대상으로 더티 체킹이 일어난다.(비영속, 준영속처럼 영속성 컨텍스트의 관리를 받지 못하는 엔티티는 값을 변경해도 데이터베이스에 반영되지 않는다.)        ✔️ 영속성 콘텍스트영속성 컨텐스트란 엔티티를 영구 저장하는 환경이라는 뜻이다. 애플리케이션과 데이터베이스 사이에서 객체를 보관하는 가상의 데이터베이스 같은 역할을 한다. 엔티티 매니저를 통해 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.  기본적으로 더티 체킹을 실행하면, SQL에서는 변경된 엔티티의 모든 내용을 update 쿼리로 만들어 전달하는데, 이때 필드가 많아지면 전체 필드를 update하는게 비효율적일 수도 있다.이때는 @DynamicUpdate를 해당 Entity에 선언하여 변경 필드만 반영시키도록 만들어줄 수 있다 공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다. 참고링크는 맨 아래 있습니다. 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. (참고링크)  JPA 더티 체킹(Dirty Checking)이란?  [Spring JPA] Dirty Checking(더티체킹)이란?  JPA 영속성 컨텍스트란?  [Spring Data JPA] 더티 체킹 (Dirty Checking)"
  },
  
  {
    "title": "/Database/ 💚 관계형 데이터베이스(RDB)",
    "url": "/posts/RDB/",
    "categories": "03.STUDY, Database",
    "tags": "STUDY",
    "date": "2023-01-14 00:00:00 +0900",
    





    
    "snippet": "(참고링크)  관계형 데이터베이스란 무엇인가요?  관계형 데이터베이스(RDBMS)란?  관계형 데이터베이스 공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다. 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. ",
    "content": "(참고링크)  관계형 데이터베이스란 무엇인가요?  관계형 데이터베이스(RDBMS)란?  관계형 데이터베이스 공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다. 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. "
  },
  
  {
    "title": "/Database/ 정규화",
    "url": "/posts/Normalization/",
    "categories": "03.STUDY, Database",
    "tags": "STUDY",
    "date": "2023-01-14 00:00:00 +0900",
    





    
    "snippet": "정규화Normalization      관계형 데이터베이스의 설계에서중복을 최소화하기 위해 데이터를 구조화하는 프로세스를 정규화라고 합니다.        정규화의 기본 목표          관련이 없는 함수 종속성은 별개의 릴레이션으로 표현하는 것      테이블 간에 중복된 데이터를 허용하지 않는다는 것      중복된 데이터를 허용하지 않음으로써:...",
    "content": "정규화Normalization      관계형 데이터베이스의 설계에서중복을 최소화하기 위해 데이터를 구조화하는 프로세스를 정규화라고 합니다.        정규화의 기본 목표          관련이 없는 함수 종속성은 별개의 릴레이션으로 표현하는 것      테이블 간에 중복된 데이터를 허용하지 않는다는 것      중복된 데이터를 허용하지 않음으로써:무결성(Integrity)를 유지할 수 있으며, DB의 저장 용량 역시 줄일 수 있다.        ✔️ 비정규화 복잡한 쿼리 속도를 높이고 성능을 향상시키기 위해 테이블에 중복 데이터를 추가하는 프로세스입니다.  ✔️ 관계형 데이터베이스(RDB) 테이블, 행, 열의 정보를 구조화하는 방식입니다. RDB에는 테이블을 조인하여 정보 간 관계 또는 링크를 설정할 수 있는 기능이 있어, 여러 데이터 포인트 간의 관계를 쉽게 이해하고 정보를 얻을 수 있습니다.정규화 장점  데이터베이스 변경 시 이상 현상(Anomaly)을 제거할 수 있다.  정규화된 데이터베이스 구조에서는 새로운 데이터 형의 추가로 인한 확장 시,그 구조를 변경하지 않아도 되거나 일부만 변경해도 된다.  데이터베이스와 연동된 응용 프로그램에 최소한의 영향만을 미치게 되어 응용프로그램의 생명을 연장시킨다.  이상 현상의 발생 가능성을 줄일 수 있다.정규화 단점  릴레이션의 분해로 인해 릴레이션 간의 JOIN연산이 많아진다.  질의에 대한 응답 시간이 느려질 수도 있다.  데이터의 중복 속성을 제거하고 결정자에 의해 동일한 의미의 일반 속성이 하나의 테이블로 집약되므로 한테이블의 데이터 용량이 최소화되는 효과가 있다.  따라서 데이터를 처리할 때 속도가 빨라질 수도 있고 느려질 수도 있다.  만약 조인이 많이 발생하여 성능 저하가 나타나면 반정규화(De-normalization)를 적용할 수도 있다.  연산 시간이 증가한다.정규화 단계이러한 테이블을 분해하는 정규화 단계는테이블을 어떻게 분해되는지에 따라 정규화 단계가 달라진다.  일반적으로 제1정규형부터 보이스/코드(BCNF) 정규형까지 단계별로 질행합니다.  정규화는 실제 데이터 값이 아닌 개념적 측면에서 수행되어야 합니다.  실제 정규화 과정은 정규형 순서와 다를 수 있습니다.(상황에 따라 어떤 정규형은 건너 뛸 수도 있다.) 제1 정규화           테이블의 컬럼이 원자값(Atomic Value, 하나의 값)을 갖도록 테이블을 분해하는 것 (각 컬럼이 하나의 속성만을 가져야 한다.)      하나의 컬럼은 같은 종류나 타입(type)의 값을 가져야 한다.      각 컬럼이 유일한(unique) 이름을 가져야 한다.      칼럼의 순서가 상관없어야 한다.            정규화가 필요한 테이블        ⬇️    정규화 이후        (사진출처)   제2 정규화           제1 정규화를 진행한 테이블에 대해 완전 함수 종속을 만족하도록 테이블을 분해하는 것      모든 컬럼이 부분적 종속(Partial Dependency)이 없어야 한다.== 모든 칼럼이 완전 함수 종속을 만족해야 한다.            정규화가 필요한 테이블    ⬇️    정규화 후        (사진출처)   제3 정규화           제2 정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 테이블을 분해하는 것      2 정규형을 만족해야 한다.      기본키를 제외한 속성들 간의 이행 종속성 (Transitive Dependency)이 없어야 한다.            정규화가 필요한 테이블        ⬇️    정규화 후        (사진출처)   BCNF 정규화           제3 정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해하는 것      3정규형을 만족해야 한다.      모든 결정자가 후보키 집합에 속해야 한다.            정규화가 필요한 테이블        ⬇️    정규화 후        (사진출처)   제4 정규화 이상         (사진출처)    보통 정규화는 BCNF 까지만 하는 경우가 많고,그 이상 정규화를 하면 정규화의 단점이 나타날 수도 있다.  역정규화정규화를 거치면 릴레이션 간의 연산(JOIN 연산)이 많아지는데,이로인해 성능이 저하될 우려가 있습니다.  역정규화를 하는 가장 큰 이유는성능 문제가 있는(읽기작업이 많이 필요한) DB의 전반적인 성능을 향상시키기 위함입니다.(참고링크)  데이터베이스 정규화(Normalization)란  정규화  [DB] 정규화(Normalization)란? 정규화 예시, 1NF, 2NF, 3NF, BCNF 공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다. 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. "
  },
  
  {
    "title": "/Java/ Annotation",
    "url": "/posts/annotation/",
    "categories": "03.STUDY, Java",
    "tags": "STUDY",
    "date": "2023-01-13 00:00:00 +0900",
    





    
    "snippet": "📌 Annotation  사전적 의미로는 주석이라는 뜻이다.  클래스와 메서드에 추가하는 것이다.  특별한 의미를 부여하거나 다양한 기능을 부여하는 역할을 한다.  주로 데이터를 문서화하거나, 컴파일 타임이나 런타임시에 원하는 동작을 수행할 수 있도록 하는 데 사용된다.  프로그램에게 추가적인 정보를 제공해주는 메타데이터라고 볼 수 있다.(meta d...",
    "content": "📌 Annotation  사전적 의미로는 주석이라는 뜻이다.  클래스와 메서드에 추가하는 것이다.  특별한 의미를 부여하거나 다양한 기능을 부여하는 역할을 한다.  주로 데이터를 문서화하거나, 컴파일 타임이나 런타임시에 원하는 동작을 수행할 수 있도록 하는 데 사용된다.  프로그램에게 추가적인 정보를 제공해주는 메타데이터라고 볼 수 있다.(meta data : 데이터를 위한 데이터)  어노테이션이 나오기 전까지 메타데이터는 프로퍼티 파일과 XML파일을 활용하였다.Annotation 장점  코드량 감소, 코드의 가독성 증대  관련 코드 곁에 메타데이터를 설정할 수 있으므로 코드의 가독성 증대 됨  개발 효율성 증대          복잡한 XML 스키마를 파악하지 않아도 됨      개발시 개발 툴과 컴파일러의 도움을 받을 수 있으므로 개발 효율성이 증대됨        유지보수하기도 쉬워짐  생산성도 증가됨  별도의 파서를 적용하지 않고도 간단히 런타임 시에 활용할 수 있는 편리함  JUnit, Framework, Permission Module 에서 사용Annotaion 단점  모듈 또는 애플리케이션의 메타 데이터를 설정할 수 없다.  클래스 단위 패키지 레벨이 한정되기 때문에여러 클래스에 공통적으로 어노테이션을 설정할 수 없다.     Annotaion 사용순서  어노테이션을 정의한다.  클래스에 애노테이션을 배치한다.  코드가 실행되는 중에 Reflection을 이용하여 추가 정보를 획득하여 기능을 실시한다.✔️ Reflection Reflection이란 프로그램이 실행 중에 자신의 구조와 동작을 검사하고, 조사하고, 수정하는 것이다.Reflection은 프로그래머가 데이터를 보여주고, 다른 포맷의 데이터를 처리하고, 통신을 위해 serialization(직렬화)를 수행하고, bundling을 하기 위해 일반 소프트웨어 라이브러리를 만들도록 도와준다.Annotation 자체는 아무런 동작을 가지지 않는 단순한 표식일 뿐이지만, Reflection을 이용하면 Annotation의 적용 여부와 엘리먼트 값을 읽고 처리할 수 있다.Anotation의 형태  Marker Annotation          이름만 있는 어노테이션      @AnnotationName        Single-Element Annotation          하나의 원소만을 가지고 있는 어노테이션      @AnnotationName(elementValue)        Normal Annotation          여러 개의 원소를 갖는 어노테이션      @AnnotationName(element=value, element=value, …)       📌 Annotaion의 종류1. Spring의 대표적인 Annotaion의 종류  @Component          개발자가 생성한 Class를 Spring의 Bean으로 등록할 때 사용하는 Annotation입니다.      Spring은 해당 Annotation을 보고 Spring의 Bean으로 등록합니다.        @ComponentScan          Spring Framework는 @Component, @Service, @Repository, @Controller, @Configuration 중 1개라도 등록된 클래스를 찾으면, Context에 bean으로 등록합니다.      @ComponentScan Annotation이 있는 클래스의 하위 Bean을 등록 될 클래스들을 스캔하여 Bean으로 등록해줍니다.        @Bean          @Bean Annotation은 개발자가 제어가 불가능한 외부 라이브러리와 같은 것들을 Bean으로 만들 때 사용합니다.        @Controller          Spring에게 해당 Class가 Controller의 역할을 한다고 명시하기 위해 사용하는 Annotation입니다.        @RequestHeader          Request의 header값을 가져올 수 있으며, 해당 Annotation을 쓴 메소드의 파라미터에 사용합니다.        @RequestMapping          @RequestMapping(value=”“)와 같은 형태로 작성      요청 들어온 URI의 요청과 Annotation value 값이 일치하면 해당 클래스나 메소드가 실행됩니다.      Controller 객체 안의 메서드와 클래스에 적용 가능      Class 단위에 사용하면 하위 메소드에 모두 적용됩니다.      메소드에 적용되면 해당 메소드에서 지정한 방식으로 URI를 처리합니다.        @RequestParam          URL에 전달되는 파라미터를 메소드의 인자와 매칭시켜, 파라미터를 받아서 처리할 수 있는 Annotation으로 아래와 같이 사용합니다.      Json 형식의 Body를 MessageConverter를 통해 Java 객체로 변환시킵니다.        @RequestBody          Body에 전달되는 데이터를 메소드의 인자와 매칭시켜, 데이터를 받아서 처리할 수 있는 Annotation으로 아래와 같이 사용합니다.      클라이언트가 보내는 HTTP 요청 본문(JSON 및 XML 등)을 Java 오브젝트로 변환합니다.      클라이언트가 body에 json or xml 과 같은 형태로 형태로 값(주로 객체)를 전송하면,해당 내용을 Java Object로 변환합니다.        @ModelAttribute          클라이언트가 전송하는 HTTP parameter, Body 내용을 Setter 함수를 통해 1:1로 객체에 데이터를 연결(바인딩)합니다.      RequestBody와 다르게 HTTP Body 내용은 multipart/form-data 형태를 요구합니다.      @RequestBody가 json을 받는 것과 달리 @ModenAttribute 의 경우에는 json을 받아 처리할 수 없습니다.        @ResponseBody          @ResponseBody은 메소드에서 리턴되는 값이 View 로 출력되지 않고 HTTP Response Body에 직접 쓰여지게 됩니다.      return 시에 json, xml과 같은 데이터를 return 합니다.        @Autowired          Spring Framework에서 Bean 객체를 주입받기 위한 방법은 크게 아래의 3가지가 있습니다.      Bean을 주입받기 위하여 @Autowired 를 사용합니다.              Spring Framework가 Class를 보고 Type에 맞게(Type을 먼저 확인 후, 없으면 Name 확인) Bean을 주입합니다.                  @Autowired          생성자 (@AllArgsConstructor 사용)          setter                      @GetMapping          RequestMapping(Method=RequestMethod.GET)과 똑같은 역할을 함        @PostMapping          RequestMapping(Method=RequestMethod.POST)과 똑같은 역할함        @SpringBootTest          Spring Boot Test에 필요한 의존성을 제공해줍니다.        @Test          JUnit에서 테스트 할 대상을 표시합니다.        @configuration  외부라이브러리 또는 내장 클래스를 Bean으로 등록하고자 할 경우 사용(개발자가 직접 제어가 불가능한 클래스)1개 이상의 @Bean을 제공하는 클래스의 경우 반드시 @Configuration을 사용.  해당 클래스에서 한 개 이상의 Bean을 생성하고 있을때 선언 해주어야 함  @Transaction  데이터베이스의 상태를 변경하는 작업 또는 한번에 수행되어야 하는 연산들을 의미하고,  예외 발생 시 rollback 처리를 자동으로 수행해주는 어노테이션입니다.  +추후 다른 글에서 자세하게 다룰 예정2. Lombok의 대표적인 Annotation:Lombok은 코드를 크게 줄여주어 가독성을 크게 높힐 수 있는 라이브러리  @Setter          Class 모든 필드의 Setter method를 생성해줍니다.        @Getter          Class 모든 필드의 Getter method를 생성해줍니다.        @AllArgsConstructor          Class 모든 필드 값을 파라미터로 받는 생성자를 추가합니다.        @NoArgsConstructor          Class 기본 생성자를 자동으로 추가해줍니다.        @ToString          Class 모든 필드의 toString method를 생성한다.      📌 Annotation 비교@Component / @Configuration@Componenet와 @Configuration은 큰 차이는 없다.하지만, @Configuration의 선언부를 보면 @Component가 정의되어 있으며,@Component는 개발자가 작성한 클래스를 Bean으로 등록하고자 할 때 사용한다.✔️ @Componenet  개발자가 직접 작성한 클래스를 Bean으로 등록하고자 할 경우 사용  @Controller, @Service, @Repository 등의 어노테이션에서 상속✔️ @Configuration  외부라이브러리 또는 내장 클래스를 Bean으로 등록하고자 할 경우 사용(개발자가 직접 제어가 불가능한 클래스)  1개 이상의 @Bean을 제공하는 클래스의 경우 반드시 @Configuration을 사용.즉, 해당 클래스에서 한 개 이상의 Bean을 생성하고 있을때 선언 해주어야 함  개발자가 직접 제어 가능 : @Component  개발자가 직접 제어 불가능 : @Configuration, @Bean(참고링크)  스프링(Spring)에서 자주 사용하는 Annotation 개념 및 예제 정리  @ Annotation이란?  [Spring] @Component와 @Configuration  Annotation  @Annotaion 의미와 종류 공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다. 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. "
  },
  
  {
    "title": "/JPA/ JPA",
    "url": "/posts/jpa/",
    "categories": "03.STUDY, JPA",
    "tags": "STUDY",
    "date": "2023-01-13 00:00:00 +0900",
    





    
    "snippet": "JPAJava Persistence API  JPA는 자바 진영에서 ORM(Object-Relational Mapping) 기술 표준으로 사용되는 인터페이스의 모음  자바 어플리케이션에서 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스  실제적으로 구현된것이 아니라 구현된 클래스와 매핑을 해주기 위해 사용되는 프레임워크  JPA를 구현한 대표적...",
    "content": "JPAJava Persistence API  JPA는 자바 진영에서 ORM(Object-Relational Mapping) 기술 표준으로 사용되는 인터페이스의 모음  자바 어플리케이션에서 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스  실제적으로 구현된것이 아니라 구현된 클래스와 매핑을 해주기 위해 사용되는 프레임워크  JPA를 구현한 대표적인 오픈소스로는 Hibernate가 있다.  인터페이스 이기 때문에 Hibernate, OpenJPA 등이 JPA를 구현함JPA를 사용하면 객체를 데이터베이스에 저장하고 관리할 때, 개발자가 SQL을 작성하는 것이 아니라 JPA가 제공하는 API를 사용하면된다. 그러면 JPA가 개발자를 대신해 적절한 SQL을 생성해서 데이터베이스에 전달해 주는 역할을 해 개발자가 개발에만 집중할 수 있는 환경을 만들어줍니다.ORMObject-Relational Mapping(객체 관계 맵핑)  애플리케이션 Class와 RDB(Relational DataBase)의 테이블을 매핑(연결)한다는 뜻          객체 지향 프로그래밍은 클래스를 사용하고, 관계형 데이터베이스는 테이블을 사용한다.      객체 모델과 관계형 모델 간에 불일치가 존재한다.      ORM을 통해 객체 간의 관계를 바탕으로 SQL을 자동으로 생성하여 불일치를 해결한다.        데이터베이스 데이터 &lt;—매핑—&gt; Object 필드          객체를 통해 간접적으로 데이터베이스 데이터를 다룬다.        Persistant API라고도 할 수 있다.          Ex) JPA, Hibernate 등        기술적으로는 어플리케이션의 객체를 RDB 테이블에 자동으로 영속화 해주는 것이라고 보면된다.  (참고링크)JPA의 장점  개발자는 객체 모델을 이용하여 비즈니스 로직을 구성하는데만 집중할 수 있음.          SQL문이 아닌 Method를 통해 DB를 조작할 수 있음.      내부적으로는 쿼리를 생성하여 DB를 조작함. 하지만 개발자가 이를 신경 쓰지 않아도됨.        코드의 가독성을 높임          Query와 같이 필요한 선언문, 할당 등의 부수적인 코드가 줄어들어,각종 객체에 대한 코드를 별도로 작성        객체지향적인 코드 작성이 가능          오직 객체지향적 접근만 고려하면 되기때문에 생산성 증가      SQL아닌 객체 중심으로 개발할 수 있음        ERD를 보는 의존도를 낮출 수 있고          매핑하는 정보가 Class로 명시 되었기 때문        유지보수 및 리팩토링에 유리          개발자가 작성해야 했던 SQL과 JDBC API코드를 JPA가 다시 대신해주기 때문에 리팩토링 해야할 코드 수가 줄어듬        패러다임의 불일치 해결          상속, 연관관께, 객체 그래프 탐색, 비료하기와 같은 패러다임의 불일치 문제를 해결해줌        기존 방식에서 MySQL 데이터베이스를 사용하다가 PostgreSQL로 변환한다고 가정해보면,새로 쿼리를 짜야하는 경우가 생김. 이런 경우에 ORM을 사용한다면 쿼리를 수정할 필요가 없음JPA 단점  프로젝트의 규모가 크고 복잡하여 설계가 잘못된 경우,속도 저하 및 일관성을 무너뜨리는 문제점이 생길 수 있음  복잡하고 무거운 Query는 속도를 위해 별도의 튜닝이 필요하기 때문에결국 SQL문을 써야할 수도 있음  학습비용이 비쌈JPA가 필요한 때  객체 중심적인 개발을 할 때  SQL을 작성하지 않고 빠르게 CRUD 구현을 할 때          JPA는 반복적인 CRUD SQL을 처리해준다.      JPA는 매핑된 관계를 이용해서 SQL을 생성하고 실행하는데,      개발자는 어떤 SQL이 실행될지 생각만하면 되고,      예측도 쉽게 할 수 있다.        유지보수가 많이 필요한 상황  JPA는 네이티브 SQL이란 기능을 제공해주는데관계 매핑이 어렵거나 성능에 대한 이슈가 우려되는 경우SQL을 직접 작성하여 사용할 수 있다.JPA가 필요하지 않을 때  통계처리나 복잡한 조회 또는 성능 개선이 필요할 때는 SQL을 이용하는 것이 더 좋다.JPA / Spring JPA스프링에서 흔히 사용하는 것으로 알고있는 JPA는,JPA를 이용하는 spring-data-jpa 프레임워크이지 JPA는 아니다.(참고링크)  [Spring JPA] JPA 란?  ORM 공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다. 참고링크는 맨 아래 있습니다. 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. "
  },
  
  {
    "title": "/Sping/ MVC",
    "url": "/posts/MVC/",
    "categories": "03.STUDY, Spring",
    "tags": "STUDY",
    "date": "2023-01-12 00:00:00 +0900",
    





    
    "snippet": "MVC  ️모델(Model), 뷰(View), 컨트롤러(Controller)의 약자  애플리케이션을 세 가지 역할로 구분한 개발 방법론(디자인턴)  모델: 데이터와 비즈니스 로직을 관리합니다.  뷰: 레이아웃과 화면을 처리합니다.  컨트롤러: 명령을 모델과 뷰 부분으로 라우팅합니다.1. Model  모델은 앱이 포함해야할 데이터가 무엇인지를 정의합니다...",
    "content": "MVC  ️모델(Model), 뷰(View), 컨트롤러(Controller)의 약자  애플리케이션을 세 가지 역할로 구분한 개발 방법론(디자인턴)  모델: 데이터와 비즈니스 로직을 관리합니다.  뷰: 레이아웃과 화면을 처리합니다.  컨트롤러: 명령을 모델과 뷰 부분으로 라우팅합니다.1. Model  모델은 앱이 포함해야할 데이터가 무엇인지를 정의합니다.  데이터의 상태가 변경되면 모델을 일반적으로 뷰에게 알립니다.(따라서 필요한대로 화면을 변경할 수 있습니다.)  업데이트된 뷰를 제거하기 위해 다른 로직이 필요한 경우컨트롤러에게 알리기도 합니다.(예) 쇼핑리스트 앱에서의 Model의 역할　　: 리스트 항목이 포함해야 하는 데이터(품목, 가격, 등)와　　　이미 존재하는 리스트 항목이 무엇인지를 지정2. View  뷰는 앱의 데이터를 보여주는 방식을 정의합니다.(예) 쇼핑 리스트 앱에서의 View의 역할　　:뷰는 항목이 사용자에게 보여지는 방식을 정의하며,　　표시할 데이터를 모델로부터 받습니다.3. Controller  컨트롤러는 앱의 사용자로부터의 입력에 대한 응답으로 모델 및/또는 뷰를 업데이트하는 로직을 포함합니다.(예) 쇼핑 리스트 앱에서의 View의 역할  쇼핑 리스트는 항목을 추가하거나 제거할 수 있게 해주는 입력 폼과 버튼          업데이트할 경우:모델이 업데이트되는 것이므로 입력이 컨트롤러에게 전송되고, 모델을 적당하게 처리한다음, 업데이트된 데이터를 뷰로 전송합니다.      단순한 업데이트를 할 경우(예를 들면, 항목을 알파벳순서로 정렬한다거나, 가격이 낮은 순서 또는 높은 순서로 정렬):단순히 데이터를 다른 형태로 나타내기 위해 뷰를 업데이트할 경우에는  컨트롤러는 모델을 업데이트할 필요 없이 바로 처리할 수 있다.      MVC 패턴의 과정사용자가 #1Controller를 조작하면➡️ Controller는 #2Model을 통해 데이터를 가져오고➡️그 데이터를 바탕으로 #3View를 통해 시각적 표현을 제어하여 사용자에게 전달하게 되는 패턴입니다.MVC 패턴의 장점  Model과 View가 다른 컴포넌트들에 종속되지 않아 애플리케이션의 확장성.유연성에 유리하다.  비즈니스 로직과 UI로직을 분리하여 유지보수를 독립적으로 수행 가능하게 해준다.MVC 패턴의 단점  애플리케이션이 복잡해질수록 모델과 뷰의 관계가 복잡해지는 단점이 있습니다.          MVC패턴에서 View는 Controller에 연결되어 화면을 구성하는 단위 요소이므로다수의 View를 가질 수 있습니다.      그리고 Model은 Controller를 통해서 View와 연결되지만,Controller에 의해서 하나의 View에 연결될 수 있는 Model도 여러 개가 될 수 있어View와 Model이 서로 의존성을 띄게 됩니다.      (참고링크)  MVC  Model–view–controller 공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다. 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. "
  },
  
  {
    "title": "/Data structure/ Array, LinkedList",
    "url": "/posts/Array-ArrayList-LinkedList/",
    "categories": "03.STUDY, Data structure",
    "tags": "STUDY",
    "date": "2023-01-12 00:00:00 +0900",
    





    
    "snippet": "📌 Array(배열)  배열은 특정 크기만큼 연속된 메모리 공간에 데이터를 저장하는 자료구조  메모리 공간에 필요한 크기의 메모리 영역을 미리 잡아놓고 사용하는 자료구조이기 때문에 선언 시 그 크기를 반드시 지정해야 한다.  배열도 객체이다.1. 배열의 장점  구조가 간단하여 사용하기 쉽다.  데이터를 읽어오는 시간(접근시간, access time)이...",
    "content": "📌 Array(배열)  배열은 특정 크기만큼 연속된 메모리 공간에 데이터를 저장하는 자료구조  메모리 공간에 필요한 크기의 메모리 영역을 미리 잡아놓고 사용하는 자료구조이기 때문에 선언 시 그 크기를 반드시 지정해야 한다.  배열도 객체이다.1. 배열의 장점  구조가 간단하여 사용하기 쉽다.  데이터를 읽어오는 시간(접근시간, access time)이 가장 빠르다.          index를 통해서 데이터에 빠른 접근이 용이하다.      메모리상에서 연속적으로 저장되어 있는 특징을 갖기 때문이다.      2. 배열의 단점  배열의 크기는 처음 생성할 때 정하며 이후에는 변경할 수 없다.          크기를 변경할 수 없어서, 새로운 배열을 생성해서 데이터를 복사해야한다.      실행속도를 향상시키기 위해서는 충분히 큰 크기의 배열을 생성해야하므로 메모리가 낭비된다.        비순차적인 데이터의 추가/삭제에 시간이 많이 소요된다.          배열에 비해서 리스트 중간에 데이터를 추가하고 삭제하는 과정은 비교적 간단하지만,      데이터 연결을 재구성 해야 하는 추가적인 작업 역시 필요하다.(배열의 중간에 데이터를 추가하려면, 빈자리를 만들기 위해 다른 데이터들을 복사해서 이동시켜야 함)        배열 중간에 있는 데이터가 삭제되면 공간낭비가 발생된다.3. 언제 배열을 사용하는가  빠른 접근이 요구될 때  데이터의 삽입과 삭제가 적을 때  정적인 크기의 데이터를 다룰 때에 적합(데이터의 양이 계속해서 늘어난다거나 바뀌는 경우에는 부적합)  데이터의 크기가 작을 때  데이터의 빈공간을 채우는 방법이 필요할 때  간단하게 데이터를 쌓고 싶을 때4. 배열의 시간 복잡도      탐색 : O(1) / 순차적으로 탐색시에는 O(n)(단, 접근하고자 하는 인덱스를 알고있어야 한다.)        삽입 및 삭제          배열의 처음 또는 중간에 삽입 및 삭제: O(n) (삽입 지점 이후의 데이터를 옮겨야 하기 때문)      배열의 끝에 삽입 및 삭제: O(1)      📌 ArraysList(배열리스트)  배열의 단점을 보완한 ArrayList는크기를 정해주지 않아도 되는 가변적으로 크기가 변하는 선형 리스트이다.      Object(객체) 배열을 이용해서 데이터를 순차적으로 저장    배열과는 다르게 메모리를 연속적으로 사용하지 않는다.      일반적인 배열과 동일하게순차 리스트이고(메모리가 연속적으로 배치),index를 이용해 내부의 객체를 관리한다.    데이터가 추가되어 저장 용량을 초과하면 자동으로 부족한 만큼 용량을 늘린다.      요소를 추가하면 index 0 부터 차례대로 저장된다.    데이터의 저장순서가 유지되고, 중복을 허용한다.  기존의 Vector을 개선한 것으로Vector의 구현원리와 기능적인 측면이 동일하다고 볼 수 있다.          Array 개선 -&gt; Vector      Vector 개선 -&gt; Array List      ✔️Vector(벡터)　Vector는 미리 크기를 정해 선언해야하는 Array를 더 효율적으로 활용할 수 있게한 동적 배열구조 클래스이다.　-벡터의 장점　-마지막 위치를 추가/삭제는 쉬움　-구현이 용이　-중복을 허용하고, 랜덤적으로 직접 접근 가능 (index 사용)　-벡터의 단점　-중간에 삽입/삭제가 많은 상황에선 비효율적(배열과 마찬가지)　-다량의 데이터에서 검색이 느림　–️언제 벡터를 사용하는가　-저장하려는 데이터의 개수가 가변적일 때　-컴파일 시점에 개수를 모를 때　-중간에 데이터를 삽입/삭제할 일이 없고,　　마지막에 추가/삭제 정도만 있을 때　-랜덤하게 데이터 접근을 허용하고 싶을 때　-벡터의 시간복잡도　-탐색 : O(1)　-삽입 및 삭제　　-탐색과 맨뒤의 요소 삽입 및 삭제: O(1)　　-맨 뒤나 맨 앞이 아닌 요소를 삭제하고 삽입: 0(n)1. 배열리스트의 장점  데이터의 참조가 쉽다.(인덱스값을 기준으로 어디든 한번에 참조 가능)2. 배열리스트의 단점  배열의 길이가 정해져 있어 변경이 불가능하다.  중간의 특정 index에 데이터를 추가하거나 삭제하면index 이후에 위치한 데이터를 모두 한칸씩 앞뒤로 옮겨주어야해 비효율적이다.3. 언제 배열리스트를 사용하는가  데이터의 크기가 가변적일 때  중간에 데이터를 삽입한다거나 삭제하는 경우가 거의 없을 때💚 4. 배열리스트의 시간복잡도📌 LinkedList(연결리스트)  여러 개의 노드들이 순차적으로 연결된 형태를 갖는 자료구조  연속적인 메모리 위치에 저장되지 않는 선형 구조의 자료구조  연속된 메모리를 사용하지 않기 때문에 포인터를 사용해 메모리들을 연결한다.  각 노드는 데이터와 다음 노드를 가리키는 포인터로 이루어져 있다.  배열의 단점을 극복하기 위해 만들졌다.  불열속적으로 존재하는 데이터를 서로 연결한 형태로 구성노드(Node)❓노드(Node)컴퓨터 과학에 쓰이는 기초적인 단위이다. 노드는 대형 네트워크에서는 장치나 데이터 지점(data point)을 의미한다. 개인용컴퓨터, 휴대전화, 프린터와 같은 정보처리 장치들이 노드이다.　- Node = Data + Pointer  　- 첫번째 노드: 헤드(Head) 　- 마지막 노드:  테일(Tail)1. 연결리스트의 장점  데이터의 크기가 유동적이다.  미리 메모리 영역 할당이 필요 없다.  노드가 연결된 구조이기 때문에 삽입과 삭제가 용이하다. :새로운 데이터를 추가할 때는새로운 요소를 생성한 다음추가하고자하는 위치의 이전요소의 참조를 새로운 요소에 대한 참조로 변경해주고,새로운 요소가 그 다음 요소를 참조하도록 변경하기만 하면 되므로처리속도가 매우 빠르다  이동방향이 단방향이기 때문에 다음 요소에 대한 접근이 쉽다.2. 연결리스트의 단점  특정 데이터를 찾기 위해서는 head 부터 순차적으로 데이터 접근 속도가 느리다.          임의접근이 불가능하여 처음부터 탐색을 진행해야 함      다음 요소에 대한 접근은 쉽지만, 이전요소에 대한 접근은 어려움(이점을 보완한 것으로 doubly linked list, doubly circular linked list가 있음)      ✔️doubly linked list　-링크드리스트에 참조변수를 하나 더 추가하여 　　다음 요소에 대한 참조뿐 아니라 　　이전 요소에 대한 참조도 가능하게 한 것　-이외에는 링크드 리스트와 같다. ✔️doubly circular linked list　-더블 링크드리스트의 접근성을 보다 향상 시킨 것  　-단순히 더블 링크드 리스트의 첫번째 요소와 마지막 요소를 서로 연결시킨  배열에 비해서 리스트 중간에 데이터를 추가하고 삭제하는 과정은 비교적 간단하지만,데이터 연결을 재구성 해야 하는 추가적인 작업 역시 필요하다.  메모리 할당/삭제 때문에 성능이 저하될 수 있다.  다음 노드를 가리키는 포인터를 한번에 담을 추가 공간이 있어야 하기 때문에공간 효율이 좋지 않다.  포인터 공간이 하나이상 추가되어서 메모리가 크다.3. 언제 연결리스트를 사용하는가  삽입과 삭제 연산이 잦을 때  검색 빈도가 적을 때4. 연결리스트의 종류      단순 연결 리스트            이중 연결 리스트:데이터 앞뒤로 이동 및 탐색 가능            원형 연결 리스트:마지막 노드의 포인터가 첫번째 노드를 가리킴      5. 연결리스트의 시간 복잡도      탐색: O(n)        삽입 및 삭제: 삽입과 삭제 자체는 O(1) 이다.          연결리스트의 처음에 삽입 및 삭제: O(1)      연결리스트의 중간에 삽입 및 삭제: O(n) (탐색시간 소요)      연결리스트의 끝에 삽입 및 삭제:                  끝을 가리키는 별도의 포인터를 갖는 경우: O(1)          끝을 가리키는 별도의 포인터를 갖지 않는 경우: O(n) (탐색시간 소요)                            📎 Array / LinkedList 비교                   배열      연결리스트                  장점      인덱스를 통한 빠른 접근이 가능하다.      삽입과 삭제가 용이하다.              단점      - 삽입과 삭제가 오래 걸린다.- 배열 중간에 있는 데이터가 삭제되면, 　공간 낭비가 발생한다.      임의 접근이 불가능하여, 처음부터 탐색을 진행해야 한다.              용도      빠른 접근이 요구되고, 데이터의 삽입과 삭제가 적을 때      삽입과 삭제 연산이 잦고, 검색 빈도가 적을 때      📎 ArrayList / LinkedList 비교                   ArrayList(배열리스트)      Linked List(연결리스트)                  특징      -메모리가 연속적으로 배치-순차적인 추가삭제는 더 빠름-비효율적인 메모리사용      -배열의 단점을 극복하기 위해 만듬-데이터가 많을수록 접근성이 떨어짐              장점      1. 데이터의 참조가 쉽다.  　즉, 인덱스값을 기준으로 　어디든 한번에 참조 가능      1. 크기가 유동적이다 2. 메모리 중간에 삽입/삭제가　 자유롭다.              단점      1. 배열의 길이가 정해져있다.　(변경 불가)  2. 중간에 메모리의 삽입과 삭제가 　번거롭다.      1. 포인터 공간이 하나이상이 　추가되어서 메모리가 크다.  2. 메모리 할당/삭제때문에 성능 저하              읽기(접근시간)      빠르다      느리다              추가/삭제      느리다      빠르다      💚 ArrayList / LinkedList 사용법(메소드 등)💚 ArrayList / LinkedList  내부 구현 분석📎 java.util.Arrays 패키지  java.util.Arrays는  java.util 패키지에 포함되므로,반드시 import 문으로 java.util 패키지를 불러오고 나서 사용해야 한다.  Arrays 클래스는 정렬(sorting)이나 탐색(searching)과 같은 배열관리 메소드를 포함하고 있다.  Arrays 클래스의 메소드들은 특정 배열 참조값이 null값이면 nullPointerException이 적용된다.  배열을 목록으로 볼 수 있도록 하는 static factory 또한 포함하고 있다.  Arrays 클래스의 모든 메소드는 클래스 메소드(static method)이므로,객체를 생성하지 않고도 바로 사용할 수  있다.import java.util.Arrays;public class ArraysEx {  public static void main(String[] args) {    // 배열 선언    int[] array = { 1, 0, 4, 5, 7, 2, 8, 6, 9, 3 };    // 배열을 출력할때 for문을 이용하지만         // Arrays.toString()을 이용하면 간단하게 출력이 가능하다.        System.out.println(\"-----Arrays.toString()-----\");        System.out.println(array);        System.out.println(Arrays.toString(array));        System.out.println();                 // Arrays.sort()를 이용하면 오름차순 정렬이 되고 기존의 값을 변경 시킨다.        System.out.println(\"-----Arrays.sort()-----\");        Arrays.sort(array);        System.out.println(Arrays.toString(array));        System.out.println();                 // Arrays.binarySearch()를 이용하면 해당 특정값을 찾아준다.         // 검색 결과가 없거나 오류시 음수값을 반환한다.        // 검색하기 전에는 오름차순으로 정렬되어있어야한다. -&gt; 안그럼 음수값을 반환        System.out.println(\"-----Arrays.binarySearch()-----\");        System.out.println(Arrays.binarySearch(array, 6));        System.out.println(Arrays.binarySearch(array, 10));        System.out.println();                 // Arrays.equals()를 이용하면 두 배열을 비교할 수 있다. 같으면 true, 틀리면 false        int[] a1 = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };        int[] a2 = { 0, 1, 1, 1, 1, 1 };        System.out.println(\"-----Arrays.equals()-----\");        System.out.println(Arrays.equals(array, a1));        System.out.println(Arrays.equals(array, a2));        System.out.println();                 // Arrays.fill()를 이용하면 배열을 초기화할 수 있다.        System.out.println(\"-----Arrays.fill()-----\");        Arrays.fill(array, 0);        System.out.println(Arrays.toString(array));        Arrays.fill(array, 1);        System.out.println(Arrays.toString(array));    }}-----Arrays.toString()-----[I@14db9842][1, 5, 4, 7, 6, 2, 0, 9, 3, 8]-----Arrays.sort()-----[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]-----Arrays.binarySearch()-----6-11-----Arrays.equals()-----truefalse-----Arrays.fill()-----[0, 0, 0, 0, 0, 0, 0, 0, 0, 0][1, 1, 1, 1, 1, 1, 1 ,1 ,1 ,1] (출처) - [ Java ] 배열 다루기 ( Arrays Class ) 📎 new ArrayList()와 List.of()import java.util.ArrayList; // new ArrayList&lt;&gt;()import java.util.Arrays; // Arrays.asList()import java.util.List;\t// List.of()                   원소를 추가/삭제      set 사용 가능      null              new ArrayList&lt;&gt;()      가능      가능      null을 가질 수 있음              Arrays.asList()      불가능      가능      null을 가질 수 있음              List.of()      불가능      불가능      null을 가질 수 없음        ArrayList&lt;&gt;()          List값을 하나만 넣으려면 List.of()를 감싸서 넣으면 된다.      new ArrayList&lt;&gt;()를 사용하여 컬렉션 생성 시, 새로운 주소값으로 할당하여 의도치 않는 변화를 막는다.        Arrays.asList()          참조한 원본 배열의 값이 바뀌면 List의 값도 바뀌고, List의 값이 바뀌면 원본 배열의 값도 바뀐다.        List.of()          참조한 원본 배열의 값이 바뀌어도 List의 값은 바뀌지 않는다.        사용          테스트 코드에서 배열의 size가 변하면 안 되거나 변할 필요가 없을 때 List.of()를 사용한다.      그런데 null값을 테스트 해야한다면 Arrays.asList()를 사용한다.      📎 배열의 깊은 복사, 얕은 복사  Java의 복사          얕은 복사(Shallow copy):원본 배열이나 복사된 배열이 변경될 때 상대 배열의 값이 같이 변경된다.      깊은 복사(Deep copy):원본 배열이나 복사된 배열이 변결될 때 서로간의 값은 바뀌지 않는다.        primitive type의 변수:얕은 복사로도 문제 없이 진행된다.  reference type(객체, 배열 등)의 변수:깊은 복사를 사용해야지만 객체의 실제 데이터를 복사할 수 있다.1. 얕은 복사(Shallow Copy)int[] a = {1, 2, 3, 4};int[] b = a;System.out.println(Arrays.toString(a)); // [1, 2, 3, 4]System.out.println(Arrays.toString(b)); // [1, 2, 3, 4]// 원본 배열 값 변경a[1] = 10;System.out.println(Arrays.toString(a)); // [1, 10, 3, 4]System.out.println(Arrays.toString(b)); // [1, 10, 3, 4]// 복사한 배열 값 변경b[3] = 1111;System.out.println(Arrays.toString(a)); // [1, 10, 3, 1111]System.out.println(Arrays.toString(b)); // [1, 10, 3, 1111]얕은 복사에서는 =연산자를 사용해 해당 변수에 담겨있는 값을 복사한다. 배열의 경우 해당 변수에 heap의 데이터를 가리키는 참조값이 저장되어있기 때문에 참조값이 복사되어 같은 원본 배열을 가리키게 되는 것이다.2. 깊은 복사(Deep Copy)int[] a = {1, 2, 3, 4};int[] b = new int[a.length]; for (int i = 0; i &lt; a.length; i++) {    b[i] = a[i];}System.out.println(Arrays.toString(a)); // [1, 2, 3, 4]System.out.println(Arrays.toString(b)); // [1, 2, 3, 4]// 원본 배열 값 변경a[1] = 10;System.out.println(Arrays.toString(a)); // [1, 10, 3, 4]System.out.println(Arrays.toString(b)); // [1, 2, 3, 4]// 복사한 배열 값 변경b[3] = 1111;System.out.println(Arrays.toString(a)); // [1, 10, 3, 4]System.out.println(Arrays.toString(b)); // [1, 2, 3, 1111]이렇게 for문을 이용해 복사를 하는 방법도 있지만 java에서 지원하는 다양한 메소드(method)들을 활용하면 더 편하게 깊은 복사를 할 수 있다.  다양한 복사 메서드 참고링크📎 Array / Array List / LinkedList 사용하면 좋을 데이터의 예시와 이유✔️ 순차적으로 추가/삭제하는 경우: Array가 LinkedList보다 빠르다.✔️ 중간 데이터를 추가/삭제하는 경우: LinkedList가 ArrayList보다 빠르다.( 참고링크 &amp; 관련내용 )  배열과 연결리스트 (Array &amp; LinkedList)  [자료구조] 배열 Array, 배열 리스트 ArrayList, 연결 리스트 LinkedList  노드  배열리스트(Array List)와 연결리스트(Linked List)의 차이  다양한 복사 메서드  Arrays 클래스  java.util.Arrays  java.util.Arrays  [ Java ] 배열 다루기 ( Arrays Class )  배열(array), 행렬(matrix), 벡터(vector)에 대해 알아보자  vector와 array의 차이  vector  C++에서의 자료구조 Array 대신 Vextor를 쓰는 이유  자료구조STL vector 1탄  자료구조: Linked List 대 ArrayList - 넥스트리소프트 공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다. 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. "
  },
  
  {
    "title": "/Spring/ DI, IoC",
    "url": "/posts/di-ioc/",
    "categories": "03.STUDY, Spring",
    "tags": "STUDY",
    "date": "2023-01-11 00:00:00 +0900",
    





    
    "snippet": "📌 DIDependency Injection(의존성 주입)  스프링이 다른 프레임워크와 차별화하여 제공하는 의존 관계 주입 기능  객체를 직접 생성하는 게 아니라, 외부에서 생성한 후 주입 시켜주는 방식  DI(의존성 주입)을 사용하면 모듈 간의 결합도가 낮아지고 유연성이 높아짐📌 IoCInversion of Control(제어의 역전)스프링 애플리케...",
    "content": "📌 DIDependency Injection(의존성 주입)  스프링이 다른 프레임워크와 차별화하여 제공하는 의존 관계 주입 기능  객체를 직접 생성하는 게 아니라, 외부에서 생성한 후 주입 시켜주는 방식  DI(의존성 주입)을 사용하면 모듈 간의 결합도가 낮아지고 유연성이 높아짐📌 IoCInversion of Control(제어의 역전)스프링 애플리케이션에서는오브젝트(빈)의 생성과 의존 관계 설정, 사용, 제거 등의 작업을애플리케이션 코드 대신 스프링 컨테이너가 담당한다.이를 스프링 컨테이너가 코드 대신 오브젝트에 대한 제어권을 갖고 있다고 해서 IoC라고 부른다.스프링 컨테이너를 IoC 컨테이너라고도 부른다.  제어의 흐름을 바꿔줌  메소드나 객체의 호출작업을 개발자가 결정하는 것이 아니라,외부에서 결정되는 것  IoC를 사용하면 객체의 의존성을 역전시켜 객체 간의 결합도를 줄여줌  유연한 코드를 작성 할 수 있게 하여가독성 및 코드 중복, 유지 보수를 편하게 할 수 있음IoC 컨테이너????????      스프링에서는 IoC를 담당하는 컨테이너를빈 팩토리, DI 컨테이너, 애플리케이션 컨텍스트라고 부른다.        오브젝트의 생성과 오브젝트 사이의 런타임 관계를 설정하는 DI 관점으로 보면,컨테이너를 빈 팩토리 또는 DI 컨테이너라고 부른다.  + 애플리케이션 컨텍스트application context      스프링 컨테이너는 단순한 DI 작업보다 더 많은 일을 하는데, DI를 위한 빈 팩토리에 여러 가지 기능을 추가한 것        애플리케이션 컨텍스트는 그 자체로 IoC와 DI 그 이상의 기능을 가진것과 마찬가지  (참고링크)  [Spring] DI, IoC 정리  Ioc, DI란 무엇일까 공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다. 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. "
  },
  
  {
    "title": "/Java/ Override 와 Overload",
    "url": "/posts/override-overload/",
    "categories": "03.STUDY, Java",
    "tags": "STUDY",
    "date": "2023-01-11 00:00:00 +0900",
    





    
    "snippet": "Override와 OverloadOverride와 Overload는 메소드(기능)의 재정의 또는 확장을 위한 개념입니다.📌 Override  Override는 부모 클래스의 상속을 받은 자식 클래스에서 확장하는 개념오버라이딩을 사용하는 이유  상속받은 메소드를 그대로 사용할 수도 있지만,자식 클래스에서 상황에 맞게 변경해야하는 경우 오버라이딩할 필요가...",
    "content": "Override와 OverloadOverride와 Overload는 메소드(기능)의 재정의 또는 확장을 위한 개념입니다.📌 Override  Override는 부모 클래스의 상속을 받은 자식 클래스에서 확장하는 개념오버라이딩을 사용하는 이유  상속받은 메소드를 그대로 사용할 수도 있지만,자식 클래스에서 상황에 맞게 변경해야하는 경우 오버라이딩할 필요가 생김@Override  부모 클래스의 메소드를 오버라이딩하는 것은내용만을 새로 정의하는 것이므로선언부는 부모의 것과 완벽히 동일해야 함  @Override라는 어노테이션은 오버라이딩을 검증하는 기능,코드상으로 검사했을 때 오버라이딩이 실제로 시행되지 않았다면 컴파일시 오류를 출력오버라이딩에서의 접근 제어자를 설정하는 규칙  자식 클래스에서 오버라이딩하는 메소드의 접근 제어자는 부모 클래스보다 더 좁게 설정할 수 없다.  예외(Exception)는 부모 클래스의 메소드 보다 많이 선언할 수 없다.  static메소드를 인스턴스의 메소드로 또는 그 반대로 바꿀 수 없다.📌 Overload  Overload는 같은 클래스 내부에서 확장하는 개념  자바의 한 클래스 내에 이미 사용하려는 이름과 같은 이름을 가진 메소드가 있더라도매개변수의 개수 또는 타입이 다르면,같은 이름을 사용해서 메소드를 정의할 수 있음오버로딩의 조건  메소드의 이름이 같고, 매개변수의 개수나 타입이 달라야 함  ‘리턴 값만’ 다른 것은 오버로딩을 할 수 없음오버로딩의 특징  접근 제어자도 자유롭게 지정해 줄 수 있음  오버로딩은 매개변수의 차이로만으로도 구현가능,매개변수가 다르다면 리턴 값은 다르게 지정할 수 있음오버로딩을 사용하는 이유  같은 기능을 하는 메소드를 하나의 이름으로 사용할 수 있음  메소드의 이름을 절약할 수 있음Override와 Overload 비교            구분      Overriding      Overloading                  접근 제어자      부모 클래스의 메소드의 접근 제어자보다 더 넓은 범위의 접근제어자를  자식클래스의 메소드에서 설정 가능      모든 접근제어자 사용가능              리턴형      동일해야함      달라도됨              메소드명      동일해야함      동일해야함              매개변수      동일해야함      달라야함              적용범위      상속관계에서 적용      같은 클래스 내에서 적용됨      (참고링크)  [Java]오버로딩 &amp; 오버라이딩(Overloading &amp; Overriding) 공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다. 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. "
  },
  
  {
    "title": "✨TIL -  알고리즘문제 분석 / 스터디 첫날",
    "url": "/posts/til-230111/",
    "categories": "01.TIL/WIL, TIL",
    "tags": "TIL",
    "date": "2023-01-11 00:00:00 +0900",
    





    
    "snippet": "알고리즘문제 분석현진 매니저님이 푸신 문제들을 보며 어떻게 BufferedRedaer와 StringTokenizer를 사용하는 건지 분석해보았다. 이 메소드들을 쓸 때에는 아스키코드를 활용해 푸는 문제가 많이 보였다. 조금씩 어떻게 쓰는지 감이 잡혔고, 다음 스터디때에는 좀 더 생각하고 풀어야겠다! 스터디에서 규재님이 풀어오신 풀이를 보고 좀 놀랐다....",
    "content": "알고리즘문제 분석현진 매니저님이 푸신 문제들을 보며 어떻게 BufferedRedaer와 StringTokenizer를 사용하는 건지 분석해보았다. 이 메소드들을 쓸 때에는 아스키코드를 활용해 푸는 문제가 많이 보였다. 조금씩 어떻게 쓰는지 감이 잡혔고, 다음 스터디때에는 좀 더 생각하고 풀어야겠다! 스터디에서 규재님이 풀어오신 풀이를 보고 좀 놀랐다. 나는 잘 모른다는 이유로 분석 정도하고 필요해보이는 내용에 대해 찾아보는 정도였다. 규재님은 혼자 생각해보고 책에서 읽은 내용을 적용해 오신걸 보고 많이 배웠다.. 이번엔 책부터 읽고, 연습문제도 풀어보고 시작해보아야겠다. 고민도 많~이해 보고 내가 생각하는대로 함수를 풀어낼 수 있도록 공부해보아야겠다.스터디 첫날생각보다 내 공부와 준비가 부족했다ㅠ 스터디원들과 서로 win-win하는 관계가 되고 싶었는데, 혼자만 얻어가는 느낌이라 많이 미안했다. 오늘 부족했던 내용부터 일단 다시 채워놓고, 다음것도 잘 준비해보아야겠다. 블로그에 공부하면서 정리하는 데에 시간이 너무 소요되서, 한 시간당 한문제씩 집중해 적어보아야겠다. 정해진 시간 없이 하니깐 블로그 쓰는 시간이 효율적이지 못했다. 다음 스터디에는 준비도 더 많이해가고 다른 사람들에게 할 질문들이나 추가로 있으면 좋은 질문들까지 추가해보도록 해야겠다. 오늘도 수고많았당 ㅎㅎ"
  },
  
  {
    "title": "/etc/ 사용자의 패스워드를 전송/보관하는 방법",
    "url": "/posts/password/",
    "categories": "03.STUDY, etc",
    "tags": "STUDY, etc",
    "date": "2023-01-10 00:00:00 +0900",
    





    
    "snippet": "1. 패스워드 전송, 보관 방법먼저 클라이언트가 유저의 패스워드를 받아 평문으로 서버에 전송합니다.평문을 받은 서버는 패스워드가 복호화되지 않게단방향 해시함수로 암호화하여 보관하는 방법을 사용합니다.1-1. 스프링에서의 패스워드 전송, 보관 방법스프링에서는스프링시큐리티의 비크립트인코더를 사용해해시 함수로 인코딩하여 DB에 저장하고,이후 로그인시사용자로...",
    "content": "1. 패스워드 전송, 보관 방법먼저 클라이언트가 유저의 패스워드를 받아 평문으로 서버에 전송합니다.평문을 받은 서버는 패스워드가 복호화되지 않게단방향 해시함수로 암호화하여 보관하는 방법을 사용합니다.1-1. 스프링에서의 패스워드 전송, 보관 방법스프링에서는스프링시큐리티의 비크립트인코더를 사용해해시 함수로 인코딩하여 DB에 저장하고,이후 로그인시사용자로 부터 패스워드를 요청 받으면요청받은 패스워드를마찬가지로 해시 함수로 암호화하고DB에 암호화하여 저장했던 패스워드와 비교합니다.matches() 메서드를 사용해서일치 여부를 판단할 수 있습니다.(참고링크)   공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다. 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. "
  },
  
  {
    "title": "/Network/ CORS와 CORS 허용",
    "url": "/posts/CORS/",
    "categories": "03.STUDY, Network",
    "tags": "STUDY, Network",
    "date": "2023-01-10 00:00:00 +0900",
    





    
    "snippet": "1. CORS교차 출처 자원 공유(cross-origin-resource-sharing)여기서 교차 출처라고 하는 것은 엇갈린 다른 출처를 의미한다.CORS는 한 도메인 또는 Origin의 웹 페이지가 다른 도메인을 가진 리소스에 접근하려 할 때,보안적인 이유로 제한된 요청들을 안전하게 액세스 할 수 있게하는 HTTP 헤더 기반 보안 메커니즘이다.이전...",
    "content": "1. CORS교차 출처 자원 공유(cross-origin-resource-sharing)여기서 교차 출처라고 하는 것은 엇갈린 다른 출처를 의미한다.CORS는 한 도메인 또는 Origin의 웹 페이지가 다른 도메인을 가진 리소스에 접근하려 할 때,보안적인 이유로 제한된 요청들을 안전하게 액세스 할 수 있게하는 HTTP 헤더 기반 보안 메커니즘이다.이전에는 SOP(Same-Origin Policy) 정책이 존재하였는데,SOP는 같은 출처 내에서만 요청을 허용했기 때문에 제한 사항이 컸다.2. CORS 에러보통 Same Origin/Cross Origin 정책의 정보 부족으로 인해, 정책을 위반하는 행동을 하게 되면 CORS 에러가 나타나게 된다.에러코드를 살펴보면 이런내용이다.Access to fetch at ‘https://myhompage.com’ from origin ‘http://localhost:3000’ has been blocked by CORS policy: No Access-Control-Allow-Origin header is present on the requested resource. If an opaque response serves your needs, set the request’s mode to ‘no-cors’ to fetch the resource with CORS disabled.‘https://myhomepage.com’에서 ‘https://localhost:3000’ 출처로 가져올 수 있는 액세스가 CORS 정책에 의해 차단되었습니다. 요청된 리소스에 Access-Control-Allow-Origin 헤더가 없습니다. 불투명한 응답이 필요에 적합한 경우, 요청 모드를 ‘no-cors’로 설정하여 CORS가 비활성화된 리소스를 가져오십시오.내 홈페이지 https://myhomepage.com 에서다른 홈페이지 출처의 http://localhost:3000 의 리소스를 가져오는데 있어CORS 정책으로 인해 차단된 것이다.2-1. Origin(출처)👉 Origin(출처)  Protolcol 과 Host 그리고 Port 까지 모두 합친 URL을 의미          Protocol(Scheme) : http, https      Host : 사이트 도메인      Port : 포트 번호        https://   www.domain.com   :3000/(Protolcol)       (Host)         (Port) 👉 출처(Origin)의 동일함을 판단하는 방법  두 URL의 구성 요소 중 Protocol(Scheme), Host, Port 이 3가지만 동일하다면 동일 출처로 판단한다.✔️ ️URL　1. Protocol(Scheme) : http, https　2. Port : 포트 번호　3. Path : 사이트 내부 경로　4. Query string : 요청의 key와 value값　5. Fragment : 해시 태그3.  SOP(동일 출처 정책)Same-Origin Policy👉 SOP(Same Origin Policy)  동일한 출처에서만 리소스를 공유할 수 있다.          동일 출처(Same-Origin) 서버에 있는 리소스는 자유로이 가져올수 있지만,      다른 출처(Cross-Origin) 서버에 있는 이미지나 유튜브 영상 같은 리소스는상호작용이 불가능하다는 말이다.      3-1. SOP(동일 출처 정책)이 필요한 이유출처가 다른 두 어플리케이션이 자유롭게 소통할 수 있는 환경은 악의적으로 홈페이지에 접속하려는 사람들에게 이용되기 쉽다. 제약이 없다면 우리가 만들 어플리케이션에서 해커들이 심어놓은 코드가 실행되어 개인정보를 빼앗길 수도 있을 것이다.만약 사용자가 악성 사이트에 접속했을 경우,이때 해커가 몰래 심어놓은 악의적인 자바스크립트가 실행되어, 사용자가 모르는 사이에 어느 포털 사이트에 요청을 보내게 될 것이다. 그럼 포털 사이트에서 해당 브라우저의 쿠키를 이용하여 로그인을 하거나 개인정보를 보냈을 경우,사이트에서 해커서버로 그 정보들을 재차 보내게 되어 우리의 개인정보가 유출당할 수 있다.이외에도 사용자가 접속중인 내부망의 아이피와 포트를 가져오거나 해커가 사용자 브라우저를 프록시처럼 악용할 수도 있다.따라서 이러한 악의적인 경우를 방지하기 위해,SOP 정책으로 동일하지 않는 다른 출처의 스크립트가 실행되지 않도록 브라우저에서 사전에 방지를 해줄 수 있다.  ✔️ 프록시 서버클라이언트가 이를 통해서 통해서 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해 주는 컴퓨터 시스템이나 응용 프로그램을 가리킨다. 서버와 클라이언트 사이에 중계기로서 대리로 통신을 수행하는 것을 가리켜 ‘프록시’, 그 중계 기능을 하는 것을 프록시 서버라고 부른다.4. CORS 허용👉 서버에서의 허용  서버측 응답에서 접근 권한을 주는 Access-Control-Allow-Origin 응답 헤더를 추가:브라우저가 해당 origin이 리소스에 접근할 수 있도록 해줄 수 있습니다. 응답 헤더에 있는 Access-Control-Allow-Origin에 있는 도메인과, 요청 헤더에 있는 도메인을 확인해 출처를 비교해서 허용해 주는 방법입니다.👉 클라이언트에서는의 허용  프록시 서버를 이용해 도메인 주소를 같게 만들어 주는 방법(참고링크)  악명 높은 CORS 개념 &amp; 해결법 - 정리 끝판왕  프록시 서버  Authoritative guide to CORS (Cross-Origin Resource Sharing) for REST APIs 공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다. 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. "
  },
  
  {
    "title": "/Java/ call by value, call by reference",
    "url": "/posts/call-by-reference.md/",
    "categories": "03.STUDY, Java",
    "tags": "STUDY",
    "date": "2023-01-10 00:00:00 +0900",
    





    
    "snippet": "인수전달방법함수를 호출할 때에는함수에 필요한 데이터를 인수(argument)로 전달해 줄 수 있다.이렇게 함수에 인수를 전달하는 방법에는 크게 다음과 같이 두 가지 방법이 있습니다.  값에 의한 전달(call by value)  참조에 의한 전달(call by reference)1. call by reference(참조에 의한 전달)  함수의 호출 방...",
    "content": "인수전달방법함수를 호출할 때에는함수에 필요한 데이터를 인수(argument)로 전달해 줄 수 있다.이렇게 함수에 인수를 전달하는 방법에는 크게 다음과 같이 두 가지 방법이 있습니다.  값에 의한 전달(call by value)  참조에 의한 전달(call by reference)1. call by reference(참조에 의한 전달)  함수의 호출 방식 중 하나      메서드에서 사용되는 파라미터가 값이 아닌 (= 함수에서 인수로 변수의 값을 전달하는 대신)주소를 참조하여 데이터에 직접 접근할 수 있게 하는 호출 (= 주소값을 전달하는 방식)    java는 대체적으로 call by reference  shallow copy(얕은 복사)라고도 불린니다.1-1. call by reference 사용함수 호출시 인자로 전달되는 변수의 레퍼런스를 전달하고, (해당 변수를 가르킨다.)함수 안에서 인자의 값이 변경되면,아규먼트로 전달된 객체의 값도 함께 변경된다.(=전달받은 값을 변경할 경우 원본도 같이 변경된다.)reference type(참조 자료형)을 넘길 시에는  해당 객체의 주소값을 복사하여 사용합니다.원본 객체의  프로퍼티까지는 접근이 가능하나, 원본 객체 자체를 변경할 수는 없습니다.1-2. 자바에서의 사용?️자바는 (C/C++ 같이) 변수의 주소값 자체를 가져올 방법이 없고,이를 넘길 수 있는 방법 또한 가지고 있지 않습니다.그래서 자바는 항상 call by value 로만 동작하고, Reference 값을 넘기는 것만 가능합니다.(인자를 전달하는 두가지 방식 : call by value, call by reference)2. call by value(값에 의한 전달 방법)  인수로 전달되는 변수가 가지고 있는 값을 함수 내의 매개변수에 복사하는 방식  이렇게 복사된 값으로 초기화된 매개변수는인수로 전달된 변수와는 완전히 별개의 변수가 됨      함수 내에서의 매개변수 조작은인수로 전달되는 변수에 아무런 영향을 미치지 않음    deep copy(깊은 복사)라고도 불린다.(참고링크)  인수 전달 방법 공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다. 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. "
  },
  
  {
    "title": "✨TIL - 알고리즘문제 / cs공부 / 원티드 프로온보딩 첫 세션",
    "url": "/posts/til-230110/",
    "categories": "01.TIL/WIL, TIL",
    "tags": "TIL",
    "date": "2023-01-10 00:00:00 +0900",
    





    
    "snippet": "알고리즘문제어제 세팅을 마치고 오늘부터 시작하려 했는데, scanner를 사용하지 않고 푸는 방식이 생각보다 많이 어려웠다;; 블로그들을 아무리 봐도 어떻게 써야할지 잘 모르겠다ㅠ 먼저 현진 매니저님이 주신 코드를 좀 분석해 이해하는 것이 좋을 것 같다.  오늘은 일단 다른 걸하고, 내일 BufferedRedaer와 StringTokenizer를 사용...",
    "content": "알고리즘문제어제 세팅을 마치고 오늘부터 시작하려 했는데, scanner를 사용하지 않고 푸는 방식이 생각보다 많이 어려웠다;; 블로그들을 아무리 봐도 어떻게 써야할지 잘 모르겠다ㅠ 먼저 현진 매니저님이 주신 코드를 좀 분석해 이해하는 것이 좋을 것 같다.  오늘은 일단 다른 걸하고, 내일 BufferedRedaer와 StringTokenizer를 사용한 코드를 분석해 적용해 보기로 한다.cs공부오늘은 종일 수진님과 cs관련헤 짧게 정리해둔 내용들을 완벽숙지하기로 했는데, 좀 더 자세하고 깊은 내용이 필요해보여 스케줄을 조절했다. 1시간에 5문제씩 외우고 서로 면접보는 형식으로 진행하려 했지만, 질문하고 답변하는 시간도 오래걸릴 것 같아 각자 녹음해보고 상태를 확인하는 방향으로 바꿨다. 나는 잘 한줄 알고 넘겼는데, 다시 들어보니 충격적이었다ㅎ 멘붕이 왔지만 산책잠깐하며 정신을 차리고 돌아왔당. 다시 녹음을 해보며 보완해야할 부분들을 체크했다. 하루에 몇 문제씩 정해서 매일 반복하는 것이 좋겠다.원티드 프로온보딩 첫 세션오늘 첫 수업이었는데 그 동안 ‘이런 것들은 알아야한다’고 들었던 내용들이 많이 나온 것 같다. node.js, javascript를 이용한 함수형 프로그래밍에 관한 내용인데, 전에 피드백 나왔던 내용에 들어있는 map, filter, reduce에 관한 내용도 나왔다. 관련해 알고리즘 문제를 푸는 형식으로 진행되었는데 자바와 스프링을 공부한 나도 조금은 이해할 수 있을 정도의 수준이었다. 관련 내용들을 좀더 공부하고 보면 더 좋을것 같았다. 신청하길 잘 했다는 생각이 들었고, 다른 분들이랑 얘기 하던 중 또 이런 무료 세션이 있다고 해서 신청해두었다ㅎㅎ 11월달에 원티드에서도 AWS 인프라 관련된 온보딩이 있었는데 너무 나중에 알아 아쉬웠는데, AWS에서 하는 세션이라 그 아쉬움을 대신할 수 있을 것 같다. 여기저기 좋은 세션들이 많아 미리 알아두고 신청해야겠다!"
  },
  
  {
    "title": "✨TIL - 알고리즘문제 세팅 / 면접준비 / 원티드 프로온보딩 OT",
    "url": "/posts/til-230109/",
    "categories": "01.TIL/WIL, TIL",
    "tags": "TIL",
    "date": "2023-01-09 00:00:00 +0900",
    





    
    "snippet": "알고리즘문제 세팅스터디에서 알고리즘 문제도 매일 풀기로 정했고, 이제 알고리즘 문제를 풀기 위한 셋팅이 필요했다.해결한 문제들을 자동으로 커밋해주는 백준허브 확장프로그램을 다운받아 내 깃허브에 연결을 하고, 기본적인 입출력 부분에 대해 공부했당. 빠른 입출력을 위해 BufferedReader, BufferedWriter, StringTokenizer,...",
    "content": "알고리즘문제 세팅스터디에서 알고리즘 문제도 매일 풀기로 정했고, 이제 알고리즘 문제를 풀기 위한 셋팅이 필요했다.해결한 문제들을 자동으로 커밋해주는 백준허브 확장프로그램을 다운받아 내 깃허브에 연결을 하고, 기본적인 입출력 부분에 대해 공부했당. 빠른 입출력을 위해 BufferedReader, BufferedWriter, StringTokenizer, StringBuilder에 대해 알아야 한다. 그리고 지원해주는 메소드가 많아 데이터 가공할 필요가 없는 Scanner보다는 속도가 빠른 BufferedRedaer를 사용해 볼 예정이다.참고링크 : [Java] 빠른 입출력을 위한 BufferedReader, BufferedWriter, StringTokenizer, StringBuilder면접준비 ~ing지금 준비한 내용보다 조금 더 내용을 늘려야할 것 같다. 답변의 길이가 너무 짧고, 블로그로 내용을 정리하려다 보니 내용이 많이 빈약해 보인다.. 천천히 꽉꽉 채워보아야겠다.원티드 프로온보딩 OT–내일부터 온보딩 세션이 시작된다. 무슨 내용인지 잘 몰라 못 알아들을까 걱정되지만 ‘과락하지 않는코드, 주니어 수준의 최소한의 기본기, 좋은코드와 나쁜코드의 기준, 기술과제 면접 질문, 최종합격까지 도달하는 기술과제’ 같은 문구들을 보았을 땐 꼭 들어야만 할 것 같은 내용이라 기대가 된다!"
  },
  
  {
    "title": "✨TIL - 스터디 OT / CES / 영화(아바타:물의 길)",
    "url": "/posts/til-230108/",
    "categories": "01.TIL/WIL, TIL",
    "tags": "TIL",
    "date": "2023-01-08 00:00:00 +0900",
    





    
    "snippet": "스터디 OT오늘 기술매니저님이랑 하기로한 스터디 OT가 있었다. 알고리즘 관련해서는 관련 책 정해진 부분까지 읽고, 하루 1~2문제씩 백준 문제를 풀기로 했고, CS관련 면접 질문들도 정리해 공부해 보기로 했다. 원래도 매일 하고 있던 부분이지만, 앞으로는 좀 더 꽉찬 하루하루를 보낼 수 있을 것 같다🫠 일주일에 두번 모이기로 했고, 오늘 미리 해놓을...",
    "content": "스터디 OT오늘 기술매니저님이랑 하기로한 스터디 OT가 있었다. 알고리즘 관련해서는 관련 책 정해진 부분까지 읽고, 하루 1~2문제씩 백준 문제를 풀기로 했고, CS관련 면접 질문들도 정리해 공부해 보기로 했다. 원래도 매일 하고 있던 부분이지만, 앞으로는 좀 더 꽉찬 하루하루를 보낼 수 있을 것 같다🫠 일주일에 두번 모이기로 했고, 오늘 미리 해놓을 수 있을 만큼 많이 해놓아야 겠다! 원래 과제는 받고 바로 하는게 잘 된다ㅎㅎCES쉬면서 또 기사를 읽는데 CES에 관한 기사들이 많이 보였다. CES 미국 라스베이거에서 열린 세계 최대 가전.정보기술(IT)박람회라고 한다. 알고 있는 유명 회사들도 참여를 많이 하였고, 우리나라의 유명기업의 경영진들이 가서 둘러보는 기사들을 보니 정말 큰 박람회인가보다. LG의 선없는 TV, 무인 선박 등 신기한 내용들이 많았지만, 그 중에서도 헬스 케어에 관한 내용이 굉장히 많았다. 신기한게 너무 많아서 기사를 계속보는데, 새로운 것들이 계속 보였다. 나도 나중에 꼭! 가보고 싶당🤩영화(아바타: 물의 길)4d 예매에 또 실패하고, 아쉬운데로 일요일 조조로 2d를 보고왔다. 핳 괜히 봤다.. 12세 관람가라 적혀있었는데, 정말 12세 영화 같았다… 아바타1은 13년 전에 했었는데도 내용이 너무 신기해서 아직도 줄거리가 다 생각날 정도로 재미있게 본 영화였는데, 이번에는 새로운 신기한 내용이 없어서 그랬는지 전보다 흥미가 덜 했다ㅠㅠ 많이 아쉬웠지만 주말 아침에 일찍 일어나 영화를 보고 오니, 부지런히 하루를 보낸 것 같아 좀 뿌듯하다."
  },
  
  {
    "title": "✨WIL - 모의면접 / 면접준비 / 백엔드 모임",
    "url": "/posts/wil-230107/",
    "categories": "01.TIL/WIL, WIL",
    "tags": "WIL",
    "date": "2023-01-07 00:00:00 +0900",
    





    
    "snippet": "layout: defaulttitle: 23.01.07 [WIL]  모의면접 / 면접준비 / 백엔드 모임 parent: WIL / TILnav_order: 2—모의면접2번째 모의면접을 봤다 .공부한 내용은 바로 기억이나지 않아서 많이 말하지 못했다.ㅠ 인성면접이랑 태도 같은 건 좋다고 하셨는데, 공부 더하면 괜찮을 거같아서 조금 안심이 되었다. 상냥한...",
    "content": "layout: defaulttitle: 23.01.07 [WIL]  모의면접 / 면접준비 / 백엔드 모임 parent: WIL / TILnav_order: 2—모의면접2번째 모의면접을 봤다 .공부한 내용은 바로 기억이나지 않아서 많이 말하지 못했다.ㅠ 인성면접이랑 태도 같은 건 좋다고 하셨는데, 공부 더하면 괜찮을 거같아서 조금 안심이 되었다. 상냥한 면접관님을 만나서, 이런 질문에는 이런 대답을 하는게 좋다고도 조언도 많이 해주셨다. 정리해두고 열심히 공부해야겠다. 이해는 해도 말로 안 나와서 걱정이다. 연습이 많이 필요하다!면접준비면접 준비를 계속하고 있다. 가장 부족한 CS 공부를 위주로 했는데, 피드백대로 이력서에 쓴 내용 위주로 연습하고, 자바와 스프링에 관한 내용들에 대해 기본적인 내용들부터 공부를 해야겠당. 내용 제대로 이해하고 블로그로 글도 작성해보고 싶다. 다음주도 파이팅해본다.백엔드 모임같이 공부했던 백엔드 동료들과 항해하는 동안 도움을 많이 주신 기술매니저님을 만나고 왔다! 부산에서도 오시고, 강릉에서도 오셨다. 스터디얘기도 하고, 유익하고 즐거운 시간을 보냈다.ㅎㅎ"
  },
  
  {
    "title": "❗ERROR - CI / Test CSS and JS",
    "url": "/posts/0002/",
    "categories": "02.ERROR",
    "tags": "error",
    "date": "2023-01-04 00:00:00 +0900",
    





    
    "snippet": "🧶 Trouble  깃 블로그 배포중‘CI / Test CSS and JS’ 관련 에러 발생깃 블로그에 커밋을 하면 자동배포가 되는데 어느샌가부터 계속 배포중 에러가 발생했다고 메일이 오기 시작했다.블로그를 내가 원하는 대로 수정을 하면서여러가지 .css, .scss 파일들을 고쳤는데그에 관한 test 에러가 발생한 것으로 보인다.다행이 너무 친절하게...",
    "content": "🧶 Trouble  깃 블로그 배포중‘CI / Test CSS and JS’ 관련 에러 발생깃 블로그에 커밋을 하면 자동배포가 되는데 어느샌가부터 계속 배포중 에러가 발생했다고 메일이 오기 시작했다.블로그를 내가 원하는 대로 수정을 하면서여러가지 .css, .scss 파일들을 고쳤는데그에 관한 test 에러가 발생한 것으로 보인다.다행이 너무 친절하게도 어느파일에 어느부분을 수정하면 되는지 나왔다ㅠ아니.. 띄어쓰기까지 알려준다 ㅇㅅㅇ어느 문법 규칙에 띄어쓰기, 엔터까지 고려해야 하는 게 있다고 봤는데 이게 그런건가? 싶다  ❌ CI / Test CSS and JS✂️ Shooting# 시도 1 - 해결수정하라는 내용대로enter 도 추가하고, 띄어쓰기도 추가해주고 했더니해결 되었다ㅎㅎ이렇게 다 알려주다니😚"
  },
  
  {
    "title": "❗️ERROR - querydsl.jpa.impl does not exist",
    "url": "/posts/0001/",
    "categories": "02.ERROR",
    "tags": "error",
    "date": "2023-01-04 00:00:00 +0900",
    





    
    "snippet": "🧶 Trouble  간단한 QueryDsl 테스트 코드 작성후테스트를 실행해보는 중 에러 발생      com.querydsl.jpa.impl.JPAQueryFactor    org.springframework.transaction.annotation.Transactional    javax.persistence.EntityManager  import...",
    "content": "🧶 Trouble  간단한 QueryDsl 테스트 코드 작성후테스트를 실행해보는 중 에러 발생      com.querydsl.jpa.impl.JPAQueryFactor    org.springframework.transaction.annotation.Transactional    javax.persistence.EntityManager  import는 잘 되어 있었다.내 build.gradlebuildscript {\text {\t\tqueryDslVersion = \"5.0.0\"\t}}plugins {\tid 'java'\tid 'org.springframework.boot' version '2.7.0'\tid 'io.spring.dependency-management' version '1.1.0'\t// querydsl 추가\tid \"com.ewerk.gradle.plugins.querydsl\" version \"1.0.10\"\t// 추가 하지 않아도 되지만, lombok과 querydsl 같이 사용시 문제가 발생할 수 있어 추가\t// **&gt; id \"io.franzbecker.gradle-lombok\" version \"3.0.0\"}group = 'hello'version = '0.0.1-SNAPSHOT'sourceCompatibility = '11'configurations {\tcompileOnly {\t\textendsFrom annotationProcessor\t}}repositories {\tmavenCentral()}dependencies {\timplementation 'org.springframework.boot:spring-boot-starter-data-jpa'\timplementation 'org.springframework.boot:spring-boot-starter-web'//\timplementation 'org.springframework.boot:spring-boot-starter-thymeleaf'\t//querydsl 추가\timplementation \"com.querydsl:querydsl-jpa:${queryDslVersion}\"\tannotationProcessor \"com.querydsl:querydsl-apt:${queryDslVersion}\"\tcompileOnly 'org.projectlombok:lombok' \truntimeOnly 'com.h2database:h2' // DB 없이 여러가지 테스트 가능\tannotationProcessor 'org.projectlombok:lombok'\ttestCompileOnly 'org.projectlombok:lombok'\ttestAnnotationProcessor 'org.projectlombok:lombok'\ttestImplementation('org.springframework.boot:spring-boot-starter-test') {  // JUnit 5 가 기본 내장\t}}tasks.named('test') {\tuseJUnitPlatform()}// querydsl 추가 시작def querydslDir = \"$buildDir/generated/querydsl\"querydsl {\tjpa = true\tquerydslSourcesDir = querydslDir}sourceSets {\tmain.java.srcDir querydslDir}configurations {\tquerydsl.extendsFrom compileClasspath}compileQuerydsl {\toptions.annotationProcessorPath = configurations.querydsl}//querydsl 추가 끝✂️ Shooting# 시도 0(찾아본 해결 방법 중 이미 적용되어 있는 내용)  gradle 설정에서 Build and run using: IntelliJ IDEA 로 변경  spring boot 2.6 이상, Querydsl 5.0 지원 방법에 따라 build.gradle 작성# 시도 1검색해보니lombok과 querydsl 을 같이 쓰게 되면 문제가 생길 수 있다는 글을 많이 보았다.build.gradle에 아래 내용의 plugin을 추가해 보았다.id \"io.franzbecker.gradle-lombok\" version \"3.0.0\"안된다  참고링크# 시도 2querydslDir 부분을 수정해 해결하셨다는 글을 보아서 이것도 시도해 보았다.(원래)def querydslDir = \"$buildDir/generated/querydsl\"(수정) def querydslDir = 'src/main/generated'안된다 ㅇㅅㅇ# 시도 3intelliJ에서 gradle로 빌드할 경우같은 현상이 나타나는 분이 많은가 보다.settings - gradle 에서 build를 intelliJ 로 변경한 다음나는 계속 오른쪽 바에 있는 gradle을 눌러 빌드하고 있었다;;gradle 없이는 빌드 해보지 않아서.. 방법을 찾아보아야겠다!방법은 상단바에 있는 빌드를 눌러하면 된는 것이었다.그 방법으로 다시 빌드를 해보았지만 지금 문제인 테스트부분에서 에러가 나서 빌드가 되지 않았다;;테스트부분을 주석처리하고 다시 빌드 시도!빌드에 성공했당🧶 또다른 error ✂️테스트 코드가 실행되고 있지 않은 것만 확인해서이번엔 애플리케션이 잘 작동하는지 실행시켜보았는데여기에도 오류가 뜨고 있었다.문제는 Q파일에 8, 15번째 줄에 있는 @Generated 어노테이션에서 문제가 발생한 것으로 보인다.이 문제는 다행이 import 문제였다.(원래)import javax.annotation.processing.Generated;(수정)import com.querydsl.core.annotaion.Generated;querydsl.core로 import를 변경해 주며 이제 실행을 잘 되었다!이걸로 원래 해결하던 문제는 해결되진 않았다ㅠ# 시도 4 - 해결검색중 나와는 좀 다른 내용이지만혹시나하는 마음에 설정을 바꿔보았다.된다…이게 처음 설정해 놓은 상태였고,혹시나 하는 마음에 체크 하나 눌렀을 뿐인데..잘 된당…ㅠㅠ아래 내용을 읽어보니intellij모듈과 gradle모듈을 함께 사용하고 있는 지금 상태에서는꼭 활성화 해주어야 하는 내용으로 보인다ㅠ테스트 코드 작동으로 문제 해결!! 🥹참고링크그래도 또 하나 해결ㅎㅎ이제 또 다른 에러를 만나러 가본다..🤣"
  },
  
  {
    "title": "✨TIL - 블로그 시작 / 사이드프로젝트 첫회의 / 면접준비",
    "url": "/posts/til-230104/",
    "categories": "01.TIL/WIL, TIL",
    "tags": "TIL",
    "date": "2023-01-04 00:00:00 +0900",
    





    
    "snippet": "블로그 시작!Tistory에서 Velog로, Velog에서 GitBlog로 여기저기 옮겨 다니다 드디어 정착하였다.Tistory에 게시글 100개 넘게 쓰던 블로그는.. 계속 반복되는 이미지 업로드 오류로 더이상 사용할 수 없었다. 문의해봤지만 제대로 작동한다고만하는 답변에 결국 다른 블로그 사이트를 이용할 수 밖에 없었다. 아까운 내 글들ㅠ그리고 V...",
    "content": "블로그 시작!Tistory에서 Velog로, Velog에서 GitBlog로 여기저기 옮겨 다니다 드디어 정착하였다.Tistory에 게시글 100개 넘게 쓰던 블로그는.. 계속 반복되는 이미지 업로드 오류로 더이상 사용할 수 없었다. 문의해봤지만 제대로 작동한다고만하는 답변에 결국 다른 블로그 사이트를 이용할 수 밖에 없었다. 아까운 내 글들ㅠ그리고 Velog로 옮겼는데 마크다운 문법으로 작성하기 편리하고, 옆에 미리보기가 있어서 보기 너무 편리했다.하지만.. 깃블로그 너무 써보고 싶었다!!_!! 마크다운으로 작성할거라면 차라리 깃으로 하자 결정! 열심히 WIL/TIL도 써보아야겠다!사이드프로젝트 첫회의실전 프로젝트를 함께 진행했던 일탈 팀원들과 사이드 프로젝트를 하기로 했는데, 오늘 그 첫 회의를 했다. 주제 선정 때문에 고민이 많았었는데, 전에 했던 방식대로 브레인스토밍하니까 좋은 아이디어들도 많이 나오고 나름 금방 결정되어 다행이었다. 이야기 하다보니 거의 4시간이 빠르게 흘렀다. 다음주 월요일에 2번째 회의도 하고 ERD 설계도 하기로 정했다.면접준비계속해서 면접준비를 이어가고 있다. 오늘 정리한거 한번씩 다 보면서 외우려했는데, 사이드프로젝트 회의가 너무 길어졌다. 그래도 오늘 할 일! 다 하고 자야겠다. 내일은.. 내일의 할 일이 있으니.. 지금 모아놓은 질문들보다 더 알아야할 내용이 많지만, 일단 정리해 놓은 기본적인 내용부터 마스터하고 확장하기로 했다. 이것이 MVP 관점이던가ㅎㅎ 얼른 준비해본다."
  }
  
]

