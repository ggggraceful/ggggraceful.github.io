

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://localhost:4000/</id>
  <title>ggggraceful</title>
  <subtitle>ggggraceful's dev-log</subtitle>
  <updated>2023-01-28T11:48:48+09:00</updated>
  <author>
    <name>ggggraceful</name>
    <uri>http://localhost:4000/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="http://localhost:4000/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="http://localhost:4000/"/>
  <generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator>
  <rights> © 2023 ggggraceful </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>Library</title>
    <link href="http://localhost:4000/posts/library/" rel="alternate" type="text/html" title="Library" />
    <published>2023-01-28T00:00:00+09:00</published>
  
    <updated>2023-01-28T00:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/library/</id>
    <content src="http://localhost:4000/posts/library/" />
    <author>
      <name>ggggraceful</name>
    </author>

  
    
  

  
    <summary>
      





      

    </summary>
  

  </entry>

  
  <entry>
    <title>/Algorithm/ 💚 정렬알고리즘</title>
    <link href="http://localhost:4000/posts/sorting-algorithm/" rel="alternate" type="text/html" title="/Algorithm/ 💚 정렬알고리즘" />
    <published>2023-01-28T00:00:00+09:00</published>
  
    <updated>2023-01-28T00:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/sorting-algorithm/</id>
    <content src="http://localhost:4000/posts/sorting-algorithm/" />
    <author>
      <name>ggggraceful</name>
    </author>

  
    
    <category term="03.STUDY" />
    
    <category term="Algorithm" />
    
  

  
    <summary>
      





      


1. 정렬알고리즘





정렬




  
    
      안정된 정렬
      키값이 같은 요소의 순서가 정렬 전후에도 유지되는 것
    
  
  
    
      안정되지 않은 정렬
      키값이 같은 요소의 순서가 정렬 전후에도 유지되지 않는 것
    
  





  
    
      내부 정렬
      정렬할 모든 데이터를 하나의 배열에 저장할 수 있을 때에 사용하는 알고리즘
    
  
  
    
      외부 정렬
      정렬할 데이터가 너무 많아서 하나의 배열에 저장할 수 없을 때에 사용하는 알고리즘
    
  





  
    
      정렬 알고리즘의 핵심 요소
      교환, 선택, 삽입
대부분의 정렬 알고리즘은 이 3가지 요소를...
    </summary>
  

  </entry>

  
  <entry>
    <title>/Web/ JWT</title>
    <link href="http://localhost:4000/posts/jwt/" rel="alternate" type="text/html" title="/Web/ JWT" />
    <published>2023-01-27T00:00:00+09:00</published>
  
    <updated>2023-01-28T11:46:31+09:00</updated>
  
    <id>http://localhost:4000/posts/jwt/</id>
    <content src="http://localhost:4000/posts/jwt/" />
    <author>
      <name>ggggraceful</name>
    </author>

  
    
    <category term="03.STUDY" />
    
    <category term="Web" />
    
  

  
    <summary>
      





      


0. 쿠키와 세션



쿠키

최초 로그인 시 ID, PW를 가지고 로그인을 하고 난 이후
별 다른 ID, PW 없이 로그인이 된 상태에서 요청을 날릴 수 있다.

로그인 시 매번 ID, PW를 작성해서 전달해야한다.



쿠키 + 세션

ID, PW를 주고받는 대신
인증 정보 자체를 특정 세션 저장소에 저장하고,

이 값을 쿠키에 담아
클라이언트가 쿠키를 요청할 때마다 
세션 저장소에 있는 정보랑 동일한지로 로그인을 확인



1. JWT




  
    공개/개인 키를 쌍으로 사용하여 토큰에 서명할 경우
서명된 토큰은 개인 키를 보유한 서버가 이 서명된 토큰이 정상적인 토큰인지 인증
  
  
    JWT는 일반적으로 클라이언트와 서버, 서비스와 서비스 사이 통신 시
권한 인가(Autho...
    </summary>
  

  </entry>

  
  <entry>
    <title>/web/ 💚 쿠키, 세션, 캐시</title>
    <link href="http://localhost:4000/posts/cookie-session/" rel="alternate" type="text/html" title="/web/ 💚 쿠키, 세션, 캐시" />
    <published>2023-01-27T00:00:00+09:00</published>
  
    <updated>2023-01-27T00:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/cookie-session/</id>
    <content src="http://localhost:4000/posts/cookie-session/" />
    <author>
      <name>ggggraceful</name>
    </author>

  
    
    <category term="03.STUDY" />
    
    <category term="Web" />
    
  

  
    <summary>
      





      







(참고링크)


  
  쿠키(Cookie)와 세션(Session) &amp;amp; 로그인 동작 방법





 공부한 내용을 여러글과 책 읽은 내용을 바탕으로 정리하고 있습니다.
 좋은 글로 저의 공부에 도움을 주시는 분들께 감사드립니다. 



    </summary>
  

  </entry>

  
  <entry>
    <title>/JPA/ N+1 문제</title>
    <link href="http://localhost:4000/posts/N+1/" rel="alternate" type="text/html" title="/JPA/ N+1 문제" />
    <published>2023-01-27T00:00:00+09:00</published>
  
    <updated>2023-01-28T11:26:42+09:00</updated>
  
    <id>http://localhost:4000/posts/N+1/</id>
    <content src="http://localhost:4000/posts/N+1/" />
    <author>
      <name>ggggraceful</name>
    </author>

  
    
    <category term="03.STUDY" />
    
    <category term="JPA" />
    
  

  
    <summary>
      





      


1. JPA N+1 문제




  N + 1문제란 1번의 쿼리를 날렸을 때
의도하지 않은 N번의 쿼리가 추가적으로 실행되는 것




EAGER(즉시 로딩)인 경우

  JPQL에서 만든 SQL을 통해 데이터를 조회
  이후 JPA에서 Fetch 전략을 가지고 해당 데이터의 연관 관계인 하위 엔티티들을 추가 조회
  2번 과정으로 N + 1 문제 발생


LAZY(지연 로딩)인 경우

  JPQL에서 만든 SQL을 통해 데이터를 조회
  JPA에서 Fetch 전략을 가지지만, 지연 로딩이기 때문에 추가 조회는 하지 않음
  하지만, 하위 엔티티를 가지고 작업하게 되면 추가 조회가 발생하기 때문에 결국 N + 1 문제 발생





2. N+1 문제 발생 이유





2-1. 언제 발생하는가

...
    </summary>
  

  </entry>

</feed>


